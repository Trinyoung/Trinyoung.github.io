[{"content":"1. 说一下react的生命周期，以及对应的钩子函数？ React 的生命周期方法主要分为三个阶段：挂载阶段 (Mounting)、更新阶段 (Updating) 和 卸载阶段 (Unmounting)。这些生命周期方法在类组件中尤为明显，下面详细介绍各个阶段的生命周期和对应的钩子函数：\n1. 挂载阶段 (Mounting) 当组件实例被创建并插入到 DOM 中时，触发以下钩子函数：\nconstructor()\n触发时机：组件被初始化时调用。 作用：用于初始化状态 state 和绑定事件处理方法。 static getDerivedStateFromProps(props, state)\n触发时机：在组件实例化时以及每次更新前被调用。 作用：返回新的状态对象，或返回 null 表示状态不需要更新。 render()\n触发时机：每次组件渲染时调用。 作用：返回组件的 JSX。 componentDidMount()\n触发时机：组件第一次渲染完成后调用。 作用：适合进行异步请求、数据获取或设置订阅等操作。 2. 更新阶段 (Updating) 当组件的 props 或 state 发生变化时，会进入更新阶段，触发以下钩子函数：\nstatic getDerivedStateFromProps(props, state)\n与挂载阶段一致，每次更新前都会被调用。 shouldComponentUpdate(nextProps, nextState)\n触发时机：在组件更新之前调用。 作用：返回 true 或 false 决定组件是否需要重新渲染，默认返回 true。 render()\n在组件更新阶段会再次被调用，用于重新渲染组件。 getSnapshotBeforeUpdate(prevProps, prevState)\n触发时机：更新发生在 DOM 更新之前调用。 作用：捕获一些 DOM 信息，例如滚动位置，可以返回值作为 componentDidUpdate 的第三个参数。 componentDidUpdate(prevProps, prevState, snapshot)\n触发时机：组件更新后调用。 作用：可以进行 DOM 操作或再次发起请求。 3. 卸载阶段 (Unmounting) 当组件从 DOM 中移除时，触发以下钩子函数：\ncomponentWillUnmount() 触发时机：组件即将卸载和销毁时调用。 作用：可以用于清理定时器、取消订阅等。 4. 错误处理 (Error Handling) 当组件渲染或生命周期方法中抛出错误时，触发以下钩子函数：\nstatic getDerivedStateFromError(error)\n触发时机：当子组件抛出错误时调用。 作用：用于更新 state 以显示错误界面。 componentDidCatch(error, info)\n触发时机：当子组件抛出错误时调用。 作用：用于记录错误信息或进行错误处理。 React 16.3 以后新生命周期方法与已废弃方法 React 16.3 开始，推荐使用 getDerivedStateFromProps 和 getSnapshotBeforeUpdate。 旧的生命周期方法如 componentWillMount、componentWillReceiveProps 和 componentWillUpdate 在严格模式下被标记为不安全，并计划在未来版本中删除。 图示帮助理解 一个图示可以更好地帮助你了解 React 生命周期的顺序：\n1 2 3 4 Mounting: constructor → getDerivedStateFromProps → render → componentDidMount Updating: getDerivedStateFromProps → shouldComponentUpdate → render → getSnapshotBeforeUpdate → componentDidUpdate Unmounting: componentWillUnmount Error Handling: getDerivedStateFromError → componentDidCatch 总结 React 生命周期方法让我们在不同阶段对组件进行控制，类组件中常用这些钩子函数来实现数据请求、资源管理和性能优化等操作。\n2. 说一下什么是jsx? JSX (JavaScript XML) 是一种 JavaScript 的语法扩展，通常用于在 React 中描述用户界面。它看起来非常像 HTML，但实际上在浏览器中运行之前会被编译成 JavaScript 函数调用。\n特点与原理 语法类似于 HTML: JSX 允许你在 JavaScript 代码中编写类似 HTML 的标签语法，可以直接描述组件的结构，这让 UI 代码更具可读性和直观性。例如：\n1 const element = \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;; 需要编译: 浏览器无法直接理解 JSX，所以需要通过如 Babel 这样的编译器将其转换为标准的 JavaScript 代码。例如，上述 JSX 代码在编译后会变成：\n1 const element = React.createElement(\u0026#39;h1\u0026#39;, null, \u0026#39;Hello, World!\u0026#39;); 表达式与嵌套: JSX 允许在 {} 中嵌入 JavaScript 表达式。例如：\n1 2 const name = \u0026#34;John\u0026#34;; const element = \u0026lt;h1\u0026gt;Hello, {name}!\u0026lt;/h1\u0026gt;; 属性与子元素: 你可以向 JSX 元素传递属性和嵌套子元素，类似于 HTML。例如：\n1 const element = \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt;\u0026lt;h1\u0026gt;Hello, JSX!\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt;; 优势 直观性: JSX 让 UI 组件的结构与逻辑紧密结合在一起，开发者可以直观地看到组件的渲染结构。 更强的可维护性: 与分离的 HTML、CSS 和 JS 不同，JSX 通过组合组件的方式，提供了更好的模块化能力。 注意事项 JSX 是表达式: JSX 可以赋值给变量、作为函数参数、从函数中返回，灵活性很高。 属性规范: 在 JSX 中，class 应该写为 className，for 应该写为 htmlFor，以符合 JavaScript 的命名规则。 总结: JSX 是一种将 UI 与逻辑相结合的语法糖，它使得 React 组件的开发变得更高效、直观和可维护。在使用 React 开发应用时，JSX 是一种核心的工具。\n3. 对比一下react jsx 和 vue 中的 template 模板语法有何区别？ React JSX 和 Vue 中的模板语法都是用来描述视图结构的，但两者在设计理念、灵活性、语法特性等方面有明显的区别。以下是它们的主要区别：\n1. 语法层面 React JSX:\n更接近 JavaScript，允许在 JSX 中直接编写 JavaScript 表达式，因此具有更强的灵活性和可编程性。 支持 JavaScript 原生控制语句（如 if、for 等），需要借助三元表达式或逻辑运算符来实现条件渲染和列表渲染。 JSX 使用 HTML 标签作为函数调用的语法糖，实际上会被编译成 React.createElement 方法。 1 2 3 4 5 6 const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn ? \u0026lt;h1\u0026gt;Welcome back!\u0026lt;/h1\u0026gt; : \u0026lt;h1\u0026gt;Please sign in.\u0026lt;/h1\u0026gt;} \u0026lt;/div\u0026gt; ); Vue Template:\n采用类似于 HTML 的模板语法，允许使用特殊的指令（如 v-if、v-for 等）来实现条件渲染和列表渲染，这些指令更贴近 HTML，简单易用。 Vue 的模板不直接包含复杂的 JavaScript 逻辑，而是通过指令和表达式来描述视图，更注重视图的声明式描述。 1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1 v-if=\u0026#34;isLoggedIn\u0026#34;\u0026gt;Welcome back!\u0026lt;/h1\u0026gt; \u0026lt;h1 v-else\u0026gt;Please sign in.\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 2. 灵活性 React JSX:\n可以在 JSX 中编写复杂的逻辑，所有表达式都是 JavaScript 代码，具有更高的灵活性和可定制性。你可以将组件的渲染逻辑与 JavaScript 的条件判断、循环、函数等结合使用。 Vue Template:\n更强调视图与逻辑的分离，模板部分主要用于描述视图结构。虽然模板中也可以编写简单的表达式，但不支持复杂的控制逻辑，较为简洁和易读。 3. 编译原理 React JSX:\nJSX 会被编译成 React.createElement 调用，在运行时生成虚拟 DOM，最终由 React 渲染成真实 DOM。 Vue Template:\nVue 模板会被编译成渲染函数 (render 函数)，然后在运行时生成虚拟 DOM。这使得 Vue 在运行时与 React 类似，但模板语法的编译过程相对复杂。 4. 开发体验 React JSX:\n更自由和灵活，适合复杂逻辑的表达，但代码可能显得较为繁琐，尤其对于没有 JavaScript 背景的开发者来说，理解成本较高。 Vue Template:\n更接近传统 HTML，学习成本低，对于初学者和前端开发者来说更加友好，模板语法简单直观。 5. 状态与数据绑定 React JSX:\n数据绑定是单向的，需要通过 setState 或者 Hooks（如 useState）来更新组件状态。 Vue Template:\n支持双向数据绑定（使用 v-model），使得表单控件的处理更加方便。 总结 React JSX 更适合具有 JavaScript 编程能力的开发者，提供更大的灵活性和更强的逻辑处理能力。 Vue Template 则更专注于视图的声明式描述，更加易读、易学，尤其对于初学者和专注于前端视图开发的工程师更友好。 两者各有优势，选择取决于团队技术背景、项目复杂度以及开发者对视图逻辑的偏好。\n3. 说一下react 类组件和函数组件的区别？ React 类组件和函数组件是 React 中用于定义组件的两种不同方式。它们在语法、性能、特性等方面存在一定的区别，以下是它们的详细对比：\n1. 语法和定义 类组件 (Class Component):\n通过 ES6 类语法定义，继承自 React.Component，并且必须包含一个 render 方法，该方法返回 JSX。 通常使用类的方法来处理生命周期和状态。 1 2 3 4 5 6 7 8 9 10 11 12 class MyComponent extends React.Component { constructor(props) { super(props); this.state = { count: 0, }; } render() { return \u0026lt;div\u0026gt;{this.state.count}\u0026lt;/div\u0026gt;; } } 函数组件 (Function Component):\n使用 JavaScript 函数定义，直接接收 props 作为参数，并返回 JSX。 通过 React Hooks（如 useState 和 useEffect）来处理状态和生命周期。 1 2 3 4 5 function MyComponent() { const [count, setCount] = React.useState(0); return \u0026lt;div\u0026gt;{count}\u0026lt;/div\u0026gt;; } 2. 状态管理和生命周期 类组件:\n具有内置的状态管理能力，通过 this.state 和 this.setState 来管理状态。 提供了完整的生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount 等，可以更细粒度地控制组件的生命周期。 函数组件:\n没有原生的状态管理和生命周期方法，需要使用 React Hooks（如 useState、useEffect 等）来实现相同的功能。 Hooks 可以更方便地组织逻辑，并且可以在一个组件中组合多个 useEffect 实现逻辑的分离。 3. 性能和效率 类组件:\n在 React 16.8 以前，类组件是唯一可以管理状态的方式，但是由于类组件包含更多的逻辑和开销（如 this 绑定），相对来说性能不如函数组件高效。 函数组件:\n函数组件通常更轻量，不需要 this 绑定，性能上更加高效，尤其是搭配 React Hooks 的使用。 React 团队建议在新项目中优先使用函数组件，因为它们更简洁且性能更优。 4. 可读性和代码简洁性 类组件:\n代码相对复杂，容易出现冗余，特别是在状态和事件处理时需要 this 绑定。 对于初学者来说，可能会因为 this 关键字的使用而增加理解难度。 函数组件:\n代码更加简洁，易读易维护，避免了 this 相关的困扰。 更符合函数式编程的风格，可以通过 Hooks 使逻辑更直观地组合和复用。 5. 开发体验 类组件:\n由于类组件具有完整的生命周期方法，可以更明确地进行生命周期阶段的控制，适用于一些复杂的业务场景。 函数组件:\nHooks 的引入使函数组件的功能更加丰富，并且可以实现与类组件相同的状态管理和副作用处理，开发体验上更加现代化。 6. 未来趋势 React 从 16.8 版本开始引入了 Hooks，Hooks 已经成为官方推荐的管理状态和副作用的方式。React 官方表示，未来的新功能和特性会更加侧重于函数组件，因此函数组件被认为是 React 未来的发展方向。 总结 类组件 更适合传统 React 开发方式，适用于需要完整生命周期管理或对老项目进行维护的场景。 函数组件 更简洁、性能更高，结合 Hooks 提供了更强的灵活性和开发体验，是现代 React 开发的首选。 在实际开发中，建议优先使用函数组件，只有在需要兼容老项目或特定场景时才使用类组件。\n4. 为什么react 和 vue 都选择了hook？ Vue 和 React 都选择引入 Hooks 的原因主要有以下几个方面：\n1. 逻辑复用性增强 问题：在 Vue 和 React 的传统组件开发方式中，逻辑复用通常需要通过高阶组件 (HOC) 或混入 (Mixins) 来实现，这种方式会导致代码结构变得复杂，逻辑难以追踪，增加了维护成本。 Hooks 的优势：Hooks 提供了一种更加直观和轻量的方式来实现逻辑复用。开发者可以将组件中的逻辑提取到独立的 Hook 函数中，并在不同组件中直接调用，实现逻辑的共享和复用。例如，React 中的 useState、useEffect，Vue 中的 ref、watchEffect 等都使逻辑分离更加容易。 2. 函数式编程的特性 函数组件和组合式 API：Hooks 引入了函数式编程的特性，使得组件逻辑更加清晰和简洁。React 和 Vue 都在函数组件或组合式 API 中使用 Hooks，将状态和生命周期管理函数化，使代码更易读、易维护。 函数更易组合：通过 Hooks，可以更方便地将逻辑模块化，从而实现代码的组合和复用。例如，在 Vue 3 中使用 setup 函数可以将相关的逻辑组织在一起，使组件内部的代码结构更加清晰。 3. 解决组件复杂度问题 类组件的问题：React 类组件和 Vue 2.x 的选项式 API 在处理复杂状态逻辑时，会导致代码变得难以管理，特别是生命周期方法分散在各个部分，导致逻辑的割裂。而 Hooks 通过函数形式，将相关的逻辑组合到一起，解决了类组件的复杂性问题。 Hooks 带来的优势：通过 React Hooks 和 Vue 3 的组合式 API，状态、生命周期、事件等逻辑可以在一个函数作用域内处理，代码变得更加易读和维护。 4. 性能优化 更轻量的组件：函数组件加上 Hooks 在性能上往往更轻量，因为函数组件不需要实例化类，减少了内存和性能开销。 对渲染的控制：React 中的 Hooks 允许开发者通过 useMemo、useCallback 等手段来优化渲染性能。同样地，Vue 3 也引入了 computed 和 watch 来实现对性能的优化。 5. 未来的趋势和生态 统一 API 和开发体验：通过 Hooks，React 和 Vue 都实现了状态管理、生命周期管理、逻辑复用等功能的一致化，使开发体验更统一和一致，也更容易将项目从类组件过渡到函数组件或组合式 API。 社区和生态的推动：React Hooks 和 Vue 3 的组合式 API 已经得到了社区的广泛支持，越来越多的第三方库也开始兼容和支持 Hooks，推动了它们的普及。 总结 Vue 和 React 都选择 Hooks 是为了：\n提高逻辑复用性，解决原本组件开发中逻辑难以复用的问题。 提供更简洁、清晰、函数式的开发方式，改善代码组织和可维护性。 提供更强大的性能优化手段，适应现代前端开发的需求。 顺应未来的开发趋势，统一 API，推动生态发展。 两者虽然有不同的设计理念，但在 Hooks 这一点上，目标是一致的：通过函数式的方式让开发更高效、灵活、易维护。\n什么是HOC? HOC（Higher-Order Component）是 React 中的一个概念，它指的是一个函数，该函数接受一个组件作为参数，返回一个新的组件。HOC 的主要作用是将一些通用的逻辑提取出来，并将其封装成一个函数，然后通过 HOC 的方式来复用这些逻辑。 高阶组件（HOC）就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种组件的设计模式，这种设计模式是由react自身的组合性质必然产生的。我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。 1）HOC的优缺点 ● 优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。 ● 缺点∶hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖\n2）适用场景 ● 代码复用，逻辑抽象 ● 渲染劫持 ● State 抽象和更改 ● Props 更改\n哪些方法会触发React重新渲染？重新渲染render 会做些什么？ react 的事件机制是如何实现的？ React 的事件机制与传统的 DOM 事件机制有所不同，它实现了一套基于合成事件（Synthetic Event）的系统。合成事件是一种跨浏览器的事件封装，用来统一不同浏览器的事件行为，同时提高性能。下面是 React 事件机制的详细实现过程：\n1. 合成事件（Synthetic Event） React 为了解决浏览器的兼容性问题，创建了一套自己的事件系统，称为“合成事件”。合成事件是对原生事件的封装，确保在不同浏览器下事件行为一致。\n合成事件具有以下特点：\nReact 会拦截所有原生事件，并将它们转换为合成事件。 合成事件对象模仿了原生事件对象，但不直接来自浏览器的事件对象。 合成事件会被自动回收并重用，提升性能。 2. 事件委托 React 的事件处理基于事件委托机制。它并不会为每个 DOM 元素绑定事件处理器，而是在组件的根节点（通常是 document 或 #root）上统一绑定所有事件。\n事件委托的工作原理：\n当用户触发事件时，事件冒泡到根节点，在根节点上统一处理事件。 React 会根据触发事件的目标元素和事件类型，在内部进行事件调度和分发，找到对应的组件和事件处理函数。 这样做的好处：\n减少内存消耗：不需要为每个元素都绑定独立的事件处理器。 简化事件管理：所有事件都集中处理，统一调度。 3. 事件冒泡与捕获 React 的事件系统支持事件冒泡和事件捕获。你可以通过 capture 属性指定是否使用捕获阶段来处理事件：\n1 \u0026lt;button onClick={handleClick} onClickCapture={handleCapture}\u0026gt;Click me\u0026lt;/button\u0026gt; onClick 默认会在冒泡阶段触发。 onClickCapture 则会在捕获阶段触发。 4. 事件池化 React 使用事件池（event pooling）来优化性能。每次触发事件时，React 并不会为每个事件分配一个新的对象，而是复用旧的事件对象。\n合成事件对象在事件处理函数执行完成后会被重置和回收，因此在事件回调函数中异步使用事件对象时，必须先调用 event.persist()，以避免事件对象被重用。\n1 2 3 4 5 6 function handleClick(event) { event.persist(); // 保留事件对象，防止其被复用 setTimeout(() =\u0026gt; { console.log(event.type); // 可以安全使用事件对象 }, 1000); } 5. 阻止默认行为与停止冒泡 与原生 DOM 事件类似，React 的合成事件也提供了 preventDefault() 和 stopPropagation() 方法来阻止默认行为和事件冒泡。\nevent.preventDefault()：阻止浏览器执行事件的默认行为。 event.stopPropagation()：阻止事件冒泡到父级元素。 6. 事件绑定方式 在 React 中，事件处理函数通常通过 JSX 的形式绑定，语法上与原生 HTML 事件不同，React 使用小驼峰命名的事件属性，例如：\n1 \u0026lt;button onClick={handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt; 而不是：\n1 \u0026lt;button onclick=\u0026#34;handleClick()\u0026#34;\u0026gt;Click me\u0026lt;/button\u0026gt; 另外，React 中事件处理函数的 this 指向默认情况下不会自动绑定到组件实例，必须手动绑定或使用箭头函数处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 方法1：手动绑定 class MyComponent extends React.Component { constructor(props) { super(props); this.handleClick = this.handleClick.bind(this); } handleClick() { console.log(this); // 正确绑定到组件实例 } render() { return \u0026lt;button onClick={this.handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt;; } } // 方法2：使用箭头函数自动绑定 class MyComponent extends React.Component { handleClick = () =\u0026gt; { console.log(this); // 自动绑定到组件实例 }; render() { return \u0026lt;button onClick={this.handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt;; } } 7. 性能优化：批量更新 React 的事件处理机制与其状态更新机制结合得非常紧密。React 在事件处理函数中触发状态更新时，通常会进行批量更新，而不是每次调用 setState 都立即触发重新渲染。批量更新减少了不必要的重新渲染，提高了性能。\n总结： React 的事件机制通过合成事件、事件委托和事件池化等技术实现了高效、跨浏览器一致的事件处理系统。开发者只需使用 React 提供的事件接口，专注于业务逻辑，而不必关心底层的事件绑定和优化问题。\n说一下什么是虚拟DOM？它如何工作？ 虚拟 DOM（Virtual DOM）是 React 用于优化 UI 渲染性能的一种技术，它是对真实 DOM 的一种抽象表示，可以理解为在内存中以 JavaScript 对象形式存在的 DOM 树的副本。通过虚拟 DOM，React 可以高效地管理 UI 的更新，减少真实 DOM 操作的次数，从而提升性能。\n1. 什么是虚拟 DOM？ 虚拟 DOM 是一个轻量级的 JavaScript 对象，它表示了 DOM 树的结构，包含了真实 DOM 元素的属性、节点关系以及内容等信息。虚拟 DOM 并不直接映射到浏览器，而是存在于内存中，当状态或数据发生变化时，React 首先在虚拟 DOM 上进行计算，然后将差异更新到真实 DOM 中。\n2. 虚拟 DOM 工作流程 当组件的状态或属性发生变化时，虚拟 DOM 的更新和渲染过程一般分为以下几个步骤：\nStep 1: 构建虚拟 DOM 当应用初次渲染时，React 会根据组件的 render() 方法生成一棵虚拟 DOM 树。 这个虚拟 DOM 是由纯 JavaScript 对象组成的，描述了页面的初始状态。 Step 2: 状态更新，生成新的虚拟 DOM 当组件的 state 或 props 发生变化时，React 会重新调用 render() 方法，生成一棵新的虚拟 DOM 树。 Step 3: Diff 算法比较新旧虚拟 DOM React 会使用 “Diff 算法” 比较新的虚拟 DOM 与旧的虚拟 DOM，找出两者之间的差异（即需要更新的部分）。 Diff 算法的复杂度被优化到 O(n)，意味着它只会检查有变化的节点，忽略没有变化的部分。 Step 4: 计算差异（Reconciliation） React 将新旧虚拟 DOM 的差异（称为“补丁”或“patch”）记录下来，这些差异包含了应该如何更新真实 DOM。 Step 5: 更新真实 DOM 最后，React 会将这些差异应用到真实 DOM 中，进行必要的更新操作。由于 React 只会更新发生变化的部分，这极大地提高了渲染效率。 3. 虚拟 DOM 的优势 性能优化：与直接操作真实 DOM 相比，虚拟 DOM 通过在内存中进行计算，大幅减少了对真实 DOM 的操作次数，从而提高了性能。 跨平台能力：虚拟 DOM 是与平台无关的 JavaScript 对象，可以被用来生成多种目标输出，不仅限于浏览器的 DOM 操作。这使得 React 可以用于构建移动应用（如 React Native）。 简化开发：开发者只需关注组件的状态变化，而无需手动操作 DOM，React 会自动进行更新和渲染，提供更简洁的开发体验。 4. Diff 算法的工作原理 React 在更新虚拟 DOM 时，使用了一种高效的 Diff 算法来比较新旧虚拟 DOM 树，主要基于以下三条策略：\n同级比较：只会对同一级别的节点进行比较，不会跨级比较，这样大大降低了计算复杂度。 节点类型不同，直接替换：如果两个节点的类型不同（例如从 \u0026lt;div\u0026gt; 变为 \u0026lt;span\u0026gt;），则会直接移除旧节点及其子节点，并创建新的节点。 通过 key 进行列表比较：当渲染列表时，React 通过每个节点的 key 值来识别节点的身份，从而准确、高效地处理节点的增删改操作。 5. 虚拟 DOM 的局限性 初次渲染性能：虚拟 DOM 在初次渲染时会生成整个虚拟 DOM 树，对于大型应用来说，初次渲染的性能可能会受到影响。 不适用于所有场景：在高性能要求的场景（如 WebGL、游戏开发）中，手动优化可能比虚拟 DOM 更有效。 总结 虚拟 DOM 是 React 提高渲染性能的核心技术，通过在内存中维护一个虚拟的 DOM 树，将每次状态变化引起的 DOM 更新变得更高效。它通过 Diff 算法计算新旧虚拟 DOM 之间的差异，并将最小的更新应用到真实 DOM，从而实现性能的优化和快速的界面更新。\n对react fiber的理解，它解决了什么问题？ React Fiber 是 React 16 版本引入的新架构，它是一种用于协调和渲染 React 应用的渐进式调度算法，旨在提高 React 应用的性能，特别是对于大型应用和复杂的动画效果。\n1. 为什么需要 Fiber React 在早期的版本中，使用的是同步递归渲染机制，这意味着在一次更新中，React 会从根节点开始递归地进行渲染工作，直到整个组件树渲染完成。在大型组件树或复杂的渲染过程中，这可能会导致浏览器阻塞，导致页面卡顿或无法响应用户的交互。\n为了提升性能和提高渲染的流畅度，React Fiber 引入了一种新的架构，能够将渲染工作拆分成更小的任务单元，并允许在任务之间进行调度，从而更好地控制渲染的优先级，避免阻塞主线程。\n2. React Fiber 的核心概念 Fiber 是一种数据结构：它将每个组件的更新任务以链表的形式存储，形成一个Fiber 树，使得 React 可以逐步地、增量地更新视图。 可中断的渲染：Fiber 的最大优势是能够将渲染过程切分成小块，并且在必要的时候暂停、恢复或终止渲染任务，以确保高优先级的任务（如用户交互）能及时响应。 优先级调度：Fiber 会根据不同任务的优先级分配时间片（time slices）。这样高优先级的任务（如动画、输入事件）会比低优先级的任务（如数据加载）更早地得到处理。 3. React Fiber 的工作阶段 React Fiber 分为两个主要的阶段：\n调度阶段（Reconciliation Phase）：这一阶段是计算哪些组件需要更新的过程。Fiber 会遍历整个 Fiber 树，构建一个新版本的 Fiber 树，并确定要进行的更改。在这一步中，Fiber 可以暂停或中断，等待空闲时间继续执行。\n提交阶段（Commit Phase）：这一阶段是将更新应用到实际的 DOM 中。在这个阶段，操作是真正同步执行的，并且无法被打断。\n4. Fiber 和传统 Stack Reconciler 的区别 可中断性：传统的 Stack Reconciler 是同步的、递归的，不能中断，而 Fiber 是异步的、可中断的。 优先级控制：Fiber 能根据任务的重要性对任务进行调度，而传统架构无法做到这一点。 5. Fiber 的应用场景 动画和流畅的用户交互：Fiber 能够让 React 应用在复杂的动画、过渡效果下保持流畅。 大型组件树：对于渲染庞大组件树的应用，Fiber 能有效减少卡顿，确保高优先级的任务可以及时得到响应。 6. Fiber 的限制 虽然 React Fiber 引入了很多优点，但它也有一定的复杂性，例如调度算法的复杂性更高，同时它也会引入一定的性能开销，因此它并不是万能的优化工具，而是解决特定场景下性能问题的一种方案。\n总结 React Fiber 提供了一种更灵活、更高效的渲染方式，通过引入渐进式的调度机制，实现了对渲染任务的可中断和优先级调度，从而在提高性能和流畅度方面提供了巨大优势。\nReact Component 和 PureComponent 的区别？ 默认行为：\nComponent 是 React 中的基本组件类，它不保证任何性能优化措施。 PureComponent 是对 Component 的一个优化版本，它实现了 shouldComponentUpdate 生命周期方法，提供了浅比较（shallow comparison）的优化。 性能优化：\n使用 Component 时，开发者需要手动实现 shouldComponentUpdate 方法来控制组件是否需要更新。 PureComponent 自动实现了一个简单的 shouldComponentUpdate 实现，它会比较新旧 props 和 state，如果它们的引用不同或者值不同，则认为需要更新组件。这种浅比较可以避免不必要的渲染，提高性能。 适用场景：\n如果组件的 props 或 state 变化频繁且复杂，不适合使用 PureComponent，因为它的浅比较机制可能无法准确判断是否需要更新。 对于简单且输入输出关系明确的组件，使用 PureComponent 可以减少开发者的负担，并且提升应用性能。 自定义比较逻辑：\n在 Component 中可以通过自定义 shouldComponentUpdate 来实现更复杂的比较逻辑或条件判断。 PureComponent 不支持自定义 shouldComponentUpdate 的逻辑，如果需要更复杂的逻辑，仍然需要使用普通的 Component 并手动实现该方法。 总结来说，PureComponent 是一种轻量级的性能优化手段，适用于大多数情况下不需要复杂比较逻辑的组件。而 Component 提供了更大的灵活性，可以根据具体需求进行更细致的性能调优\n谈一谈对 React Context 的理解 React Context 是 React 提供的一种用于在组件树中共享数据的机制，允许我们在不通过 props 逐层传递的情况下，轻松地在组件之间共享状态。以下是对 React Context 的详细理解：\n1. 主要用途 全局状态管理：Context 适合用于共享全局状态，如用户认证信息、主题设置、语言选择等。 避免 props drilling：在深层嵌套的组件中，使用 Context 可以避免通过每一层组件传递 props。 2. 创建 Context 使用 React.createContext() 创建一个 Context 对象：\n1 const MyContext = React.createContext(); 3. Provider 和 Consumer Provider：用于提供 Context 的值，包裹需要访问该值的组件。 1 2 3 \u0026lt;MyContext.Provider value={/* 共享的值 */}\u0026gt; {/* 子组件 */} \u0026lt;/MyContext.Provider\u0026gt; Consumer：用于访问 Context 的值，通常在子组件中使用。 1 2 3 \u0026lt;MyContext.Consumer\u0026gt; {value =\u0026gt; /* 使用 Context 的值 */} \u0026lt;/MyContext.Consumer\u0026gt; 4. 使用 useContext Hook 在函数组件中，可以使用 useContext Hook 更简洁地访问 Context 的值：\n1 2 3 import { useContext } from \u0026#39;react\u0026#39;; const value = useContext(MyContext); 5. 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const ThemeContext = React.createContext(\u0026#39;light\u0026#39;); function App() { return ( \u0026lt;ThemeContext.Provider value=\u0026#34;dark\u0026#34;\u0026gt; \u0026lt;Toolbar /\u0026gt; \u0026lt;/ThemeContext.Provider\u0026gt; ); } function Toolbar() { return ( \u0026lt;div\u0026gt; \u0026lt;ThemedButton /\u0026gt; \u0026lt;/div\u0026gt; ); } function ThemedButton() { const theme = useContext(ThemeContext); return \u0026lt;button className={theme}\u0026gt;I am styled by theme context!\u0026lt;/button\u0026gt;; } 6. 性能考虑 重渲染：当 Provider 的值发生变化时，所有使用该 Context 的组件都会重新渲染。因此，应该谨慎选择 Context 的值，避免不必要的重渲染。 分割 Context：如果有多个状态需要共享，可以考虑将它们分割成多个 Context，以减少重渲染的范围。 7. 适用场景 主题切换：在应用中实现主题切换功能。 用户认证：在应用中共享用户的登录状态和信息。 多语言支持：在应用中实现国际化，动态切换语言。 8. 限制 不适合频繁变化的状态：对于频繁变化的状态（如表单输入），使用 Context 可能导致性能问题，建议使用局部状态管理。 复杂性：在大型应用中，过度使用 Context 可能导致代码复杂性增加，难以维护。 9. 结合其他状态管理工具 Context 可以与其他状态管理工具（如 Redux、MobX）结合使用，作为全局状态的补充。 在小型应用中，Context 可以替代 Redux 等复杂的状态管理库。 10. 总结 React Context 是一个强大的工具，适合用于在组件树中共享状态，避免 props drilling。它提供了一种简单的方式来管理全局状态，但在使用时需要注意性能和复杂性。合理地使用 Context 可以提高代码的可读性和可维护性。\nreact 中什么是受控组件，什么是非受控组件？ 在 React 中，受控组件和非受控组件是两种处理表单输入的方式。它们的主要区别在于如何管理组件的状态。\n1. 受控组件（Controlled Components） 定义： 受控组件是指其值由 React 组件的状态（state）控制的组件。所有的输入值都通过 React 的状态管理来处理。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import React, { useState } from \u0026#39;react\u0026#39;; const ControlledComponent = () =\u0026gt; { const [value, setValue] = useState(\u0026#39;\u0026#39;); const handleChange = (event) =\u0026gt; { setValue(event.target.value); }; return ( \u0026lt;input type=\u0026#34;text\u0026#34; value={value} onChange={handleChange} /\u0026gt; ); }; 优点：\n单一数据源：所有的输入值都存储在组件的状态中，便于管理和调试。 实时验证：可以在输入时进行验证和格式化。 更好的控制：可以轻松地实现复杂的交互逻辑，如动态禁用按钮、条件渲染等。 缺点：\n性能开销：每次输入都会触发状态更新，可能导致性能问题，尤其是在大型表单中。 代码复杂性：需要编写额外的代码来管理状态和处理输入。 使用场景：\n需要实时验证和格式化输入的场景。 需要根据输入动态更新其他组件或状态的场景。 需要在表单提交时获取所有输入值的场景。 2. 非受控组件（Uncontrolled Components） 定义： 非受控组件是指其值不由 React 组件的状态控制，而是直接通过 DOM 元素的引用（ref）来访问。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import React, { useRef } from \u0026#39;react\u0026#39;; const UncontrolledComponent = () =\u0026gt; { const inputRef = useRef(null); const handleSubmit = (event) =\u0026gt; { event.preventDefault(); alert(\u0026#39;A name was submitted: \u0026#39; + inputRef.current.value); }; return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); }; 优点：\n简单性：不需要管理状态，代码更简洁。 性能：在某些情况下，性能更好，因为不需要频繁更新状态。 缺点：\n难以控制：不容易实现实时验证和格式化。 数据获取：在提交表单时需要通过 ref 获取数据，可能不够直观。 不易调试：由于数据不在 React 的状态中，调试和跟踪数据变化可能更困难。 使用场景：\n简单的表单，且不需要实时验证的场景。 需要快速实现的原型或小型应用。 处理第三方库或非 React 组件的场景。 总结 受控组件：适合需要精确控制和实时反馈的场景，提供更好的可维护性和可调试性。 非受控组件：适合简单场景，减少了状态管理的复杂性，但在复杂交互中可能不够灵活。 选择使用受控组件还是非受控组件，取决于具体的应用需求和复杂性。在大多数情况下，受控组件是推荐的做法，因为它们提供了更好的控制和可维护性。\nreact 中refs 中有哪些应用场景 在 React 中，refs（引用）是一个用于访问和操作 DOM 元素或 React 组件实例的工具。以下是一些常见的 refs 应用场景：\n1. 访问 DOM 元素 直接操作 DOM：当需要直接访问和操作 DOM 元素时，可以使用 refs。例如，聚焦输入框、滚动到特定位置等。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import React, { useRef } from \u0026#39;react\u0026#39;; const FocusInput = () =\u0026gt; { const inputRef = useRef(null); const handleFocus = () =\u0026gt; { inputRef.current.focus(); // 聚焦输入框 }; return ( \u0026lt;div\u0026gt; \u0026lt;input ref={inputRef} type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;button onClick={handleFocus}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; 2. 管理动画 控制动画：在需要控制动画的场景中，可以使用 refs 来访问 DOM 元素并应用动画效果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import React, { useRef } from \u0026#39;react\u0026#39;; const AnimatedBox = () =\u0026gt; { const boxRef = useRef(null); const handleAnimate = () =\u0026gt; { boxRef.current.style.transform = \u0026#39;translateX(100px)\u0026#39;; // 移动盒子 }; return ( \u0026lt;div\u0026gt; \u0026lt;div ref={boxRef} style={{ width: \u0026#39;100px\u0026#39;, height: \u0026#39;100px\u0026#39;, background: \u0026#39;blue\u0026#39; }} /\u0026gt; \u0026lt;button onClick={handleAnimate}\u0026gt;Animate Box\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; 3. 集成第三方库 与非 React 组件集成：在使用第三方库（如 jQuery、D3.js 等）时，可能需要直接访问 DOM 元素。 1 2 3 4 5 6 7 8 9 10 11 12 import React, { useRef, useEffect } from \u0026#39;react\u0026#39;; import $ from \u0026#39;jquery\u0026#39;; const JqueryComponent = () =\u0026gt; { const divRef = useRef(null); useEffect(() =\u0026gt; { $(divRef.current).fadeIn(); // 使用 jQuery 操作 DOM }, []); return \u0026lt;div ref={divRef} style={{ display: \u0026#39;none\u0026#39; }}\u0026gt;Hello, jQuery!\u0026lt;/div\u0026gt;; }; 4. 表单管理 非受控组件：在某些情况下，使用 refs 可以简化表单管理，尤其是在处理第三方库或需要快速实现的场景。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import React, { useRef } from \u0026#39;react\u0026#39;; const UncontrolledForm = () =\u0026gt; { const inputRef = useRef(null); const handleSubmit = (event) =\u0026gt; { event.preventDefault(); alert(\u0026#39;Input value: \u0026#39; + inputRef.current.value); // 直接访问输入值 }; return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input ref={inputRef} type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); }; 5. 访问子组件实例 获取子组件方法：在类组件中，可以使用 refs 访问子组件实例，从而调用其方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Child extends React.Component { sayHello() { alert(\u0026#39;Hello from Child!\u0026#39;); } render() { return \u0026lt;div\u0026gt;Child Component\u0026lt;/div\u0026gt;; } } class Parent extends React.Component { childRef = React.createRef(); handleClick = () =\u0026gt; { this.childRef.current.sayHello(); // 调用子组件方法 }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;Child ref={this.childRef} /\u0026gt; \u0026lt;button onClick={this.handleClick}\u0026gt;Call Child Method\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } 6. 处理焦点管理 焦点控制：在复杂的表单中，可以使用 refs 来管理焦点，确保用户体验流畅。 7. 访问组件的 DOM 节点 获取组件的 DOM 节点：在需要直接操作组件的 DOM 节点时，可以使用 refs。 8. 处理滚动位置 滚动管理：在需要控制滚动位置的场景中，可以使用 refs 来访问和操作滚动条。 总结 refs 在 React 中是一个强大的工具，适用于需要直接访问和操作 DOM 元素或组件实例的场景。尽管 refs 提供了灵活性，但应谨慎使用，避免过度依赖。通常情况下，推荐使用 React 的状态管理和生命周期方法来处理大多数场景，refs 应该用于特定的需求。\nrefs 和 useState 是 React 中用于管理状态和引用的两种不同机制。它们各自有不同的用途和特性。以下是它们之间的主要区别：\n1. 用途 useState：\n用于在函数组件中管理状态。 当状态更新时，组件会重新渲染。 适用于需要响应用户输入、异步请求或其他事件的场景。 refs：\n用于访问和操作 DOM 元素或 React 组件实例。 不会引起组件重新渲染。 适用于需要直接操作 DOM、集成第三方库或管理焦点等场景。 2. 更新机制 useState： 使用 setState 函数更新状态。 更新状态后，React 会重新渲染组件，反映最新的状态。 1 2 const [count, setCount] = useState(0); setCount(count + 1); // 触发重新渲染 refs： 直接通过 ref 对象访问 DOM 元素或组件实例。 更新 refs 的值不会触发组件重新渲染。 1 2 const inputRef = useRef(null); inputRef.current.value = \u0026#39;New Value\u0026#39;; // 不会触发重新渲染 3. 数据持久性 useState：\n状态在组件的生命周期内持久化，组件重新渲染时状态保持不变。 状态可以是基本类型、对象或数组。 refs：\nrefs 的值在组件的生命周期内持久化，但不参与 React 的渲染过程。 适合存储不需要引起渲染的值，如 DOM 引用或计时器 ID。 4. 适用场景 useState：\n适用于需要响应用户交互、表单输入、异步数据请求等场景。 适合管理需要在 UI 中反映的状态。 refs：\n适用于需要直接操作 DOM 元素、集成第三方库、管理焦点等场景。 适合存储不需要在 UI 中反映的值。 5. 性能 useState：\n由于会引起重新渲染，频繁更新状态可能会影响性能。 refs：\n由于不引起重新渲染，使用 refs 可以避免不必要的性能开销。 总结 useState 是用于管理组件状态的钩子，适合需要响应用户交互的场景。 refs 是用于访问和操作 DOM 元素或组件实例的工具，适合需要直接操作 DOM 的场景。 在实际开发中，选择使用 useState 还是 refs 取决于具体的需求和场景。通常情况下，优先使用 useState 来管理需要在 UI 中反映的状态，而在需要直接操作 DOM 或不需要引起渲染的情况下使用 refs。\n类组件和函数组件有何异同？ React 类组件和函数组件有以下异同，且代表了不同的思想：\n一、类组件与函数组件的异同 1. 定义方式 类组件：使用 ES6 的 class 关键字定义，继承自 React.Component，需要实现 render() 方法来返回 JSX。 1 2 3 4 5 class MyComponent extends React.Component { render() { return \u0026lt;div\u0026gt;Hello, Class Component\u0026lt;/div\u0026gt;; } } 函数组件：使用 JavaScript 函数定义，直接返回 JSX。 1 2 3 function MyComponent() { return \u0026lt;div\u0026gt;Hello, Function Component\u0026lt;/div\u0026gt;; } 2. 状态管理 类组件：通过 this.state 管理组件状态，使用 this.setState() 更新状态。 函数组件：原先函数组件是无状态的，但自从 React 16.8 引入 Hooks 后，可以使用 useState 等 Hook 来管理状态。 3. 生命周期 类组件：提供了丰富的生命周期方法（如 componentDidMount、componentDidUpdate、componentWillUnmount 等）来处理组件的不同阶段。 函数组件：没有直接的生命周期方法，但可以使用 useEffect Hook 模拟生命周期行为。 4. this 关键字 类组件：需要注意 this 的绑定问题，必须在构造函数中手动绑定，或者使用箭头函数解决。 函数组件：不存在 this 问题，代码更加简洁。 5. 性能 类组件：由于需要实例化，性能上会略低于函数组件。 函数组件：因为没有实例化过程，性能更优，尤其在引入 Hooks 后，可以满足大部分需求。 二、代表的思想 1. 类组件：面向对象编程 (OOP) 类组件符合面向对象编程的思想，通过 class 定义组件，可以封装状态、方法和生命周期，并支持继承。 组件状态和行为都被封装在对象实例中，组件自身具有更强的独立性。 2. 函数组件：函数式编程 (FP) 函数组件代表了函数式编程的思想，将组件视为纯函数，接收 props 作为输入，返回 UI 作为输出。 Hooks 的引入加强了函数式编程风格，使得状态和副作用也可以通过 Hook 函数实现。 函数组件更加简洁、直观，代码结构更清晰，避免了 this 的困扰，符合 React “UI 即函数”的理念。 总结 类组件和函数组件在实现方式、状态管理、生命周期和性能等方面有明显区别。 类组件代表面向对象编程思想，强调封装和继承；而函数组件代表函数式编程思想，提倡函数的纯粹性和数据不可变性。 在 Hooks 引入后，函数组件变得更加强大和灵活，React 官方也推荐优先使用函数组件进行开发。 React setState的调用原理 是的，您描述的场景基本上是正确的。在 React 中，setState 的调用是异步的，多个状态更新会被合并到一个更新队列中，直到 React 处理这些更新并进行重新渲染。以下是这个过程的详细说明：\n1. 状态更新的异步性 当您调用 setState 方法时，React 不会立即更新组件的状态和重新渲染组件。相反，它会将状态更新请求放入一个更新队列中。这种设计的目的是为了提高性能，避免不必要的渲染。\n2. 更新队列的合并 如果在同一个事件处理函数中多次调用 setState，React 会将这些状态更新合并为一个更新。这意味着，如果您在一个方法中调用了多次 setState，React 会将这些更新合并为一个状态更新操作。\n1 2 3 4 5 increment = () =\u0026gt; { this.setState({ count: this.state.count + 1 }); // 第一次更新 this.setState({ count: this.state.count + 2 }); // 第二次更新 this.setState({ count: this.state.count + 3 }); // 第三次更新 }; 在上面的例子中，虽然调用了三次 setState，但 React 会将这些更新合并为一次更新，最终只会触发一次重新渲染。\n3. 处理更新队列 React 会在合适的时机（例如事件处理完成后、定时器触发后等）处理更新队列。处理更新队列的过程如下：\n合并状态更新：React 会合并所有在同一事件循环中的 setState 调用。 计算新的状态：React 会根据合并后的状态计算出新的状态。 触发重新渲染：一旦更新队列处理完成，React 会重新渲染组件，更新虚拟 DOM，并最终更新真实 DOM。 4. 例子 以下是一个完整的例子，展示了如何在一个事件处理函数中合并多个状态更新：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Counter extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } increment = () =\u0026gt; { this.setState({ count: this.state.count + 1 }); // 更新 1 this.setState({ count: this.state.count + 2 }); // 更新 2 this.setState({ count: this.state.count + 3 }); // 更新 3 // 这里的 count 最终会是 3，而不是 6 }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {this.state.count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={this.increment}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } 5. 使用函数式更新 为了确保每次更新都基于最新的状态，您可以使用函数式更新：\n1 2 3 4 5 6 increment = () =\u0026gt; { this.setState((prevState) =\u0026gt; ({ count: prevState.count + 1 })); this.setState((prevState) =\u0026gt; ({ count: prevState.count + 2 })); this.setState((prevState) =\u0026gt; ({ count: prevState.count + 3 })); // 这里的 count 最终会是 6 }; 总结 React 的 setState 是异步的，多个状态更新会被合并到一个更新队列中。 处理更新队列时，React 会合并状态更新并触发一次重新渲染。 使用函数式更新可以确保每次更新都基于最新的状态。 这种机制使得 React 在处理状态更新时更加高效，避免了不必要的渲染和性能开销。\n完整的说一下当路由进入到当前的react页面时，整个流程是什么？ ","date":"2020-10-09T00:00:00Z","permalink":"https://trinyoung.github.io/interview/p/test-chinese/","title":"React 面试题汇总2"},{"content":"React hooks 的理解，它的实现原理是什么？ React Hooks 是 React 16.8 版本引入的一组新的 API，它允许在函数组件中使用 React 的状态和生命周期功能，从而大大增强了函数组件的能力。\n1. Hooks 的基本理解 在没有 Hooks 之前，状态管理、生命周期方法、逻辑复用等特性是通过类组件实现的，这样会导致代码难以复用和管理。React Hooks 提供了一种新的编程范式，使得你可以在函数组件中：\n管理状态（使用 useState） 访问生命周期（使用 useEffect） 使用上下文（使用 useContext） 复用逻辑（自定义 Hook） 2. Hooks 的实现原理 React Hooks 的核心在于闭包和React 的 Fiber 数据结构，通过对每个组件调用 useState、useEffect 等 Hook 函数时，对应地将状态、效果等存储在内存中的 Fiber 节点上，实现函数组件的状态管理和逻辑复用。\n2.1 Hooks 的执行顺序 每次 React 组件渲染时，函数组件会被执行，React 内部会维护一个“Hook 链表”来跟踪每个 Hook 的状态。当你多次调用 useState 或 useEffect 时，React 通过链表来跟踪每个 Hook 的位置和数据。\n2.2 useState 的工作原理 useState 内部维护了一个状态值和一个更新函数。初次渲染时，它将初始状态存储在 Fiber 节点上。 当你调用状态更新函数时，React 会将新的状态值存储到 Fiber 中，并触发组件重新渲染。新的渲染过程会根据 Hook 调用顺序更新 Hook 链表中的状态。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // useState 的简化实现 let currentHookIndex = 0; const hooks = []; function useState(initialValue) { const hookIndex = currentHookIndex; // 初始化时，将初始值存储到 hooks 数组 if (hooks[hookIndex] === undefined) { hooks[hookIndex] = initialValue; } // 更新函数，更新 hook 状态并重新渲染 const setState = (newValue) =\u0026gt; { hooks[hookIndex] = newValue; render(); // 假设这里是重新渲染函数 }; currentHookIndex++; return [hooks[hookIndex], setState]; } 2.3 useEffect 的工作原理 useEffect 在每次渲染完成后都会执行，并且会存储每个 Effect 的依赖数组。 在每次渲染时，React 会对比依赖数组是否发生变化，从而决定是否重新运行 useEffect 中的回调。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // useEffect 的简化实现 function useEffect(callback, dependencies) { const hookIndex = currentHookIndex; // 取出上一次的依赖 const hasChanged = dependencies ? !dependencies.every((item, index) =\u0026gt; item === (hooks[hookIndex]?.[index])) : true; if (hasChanged) { callback(); // 运行 callback hooks[hookIndex] = dependencies; } currentHookIndex++; } 3. React Hooks 优点 函数组件化：无需使用类组件，即可轻松地管理状态、使用副作用。 逻辑复用：通过自定义 Hook，方便地将逻辑抽取成独立的函数，提高代码的复用性。 简化代码：相比类组件，代码更简洁、更直观，减少了不必要的模板和嵌套。 4. 注意事项 Hook 调用顺序：Hooks 必须在组件顶层调用，不能放在条件语句或循环中，否则会破坏其内部状态的记录机制。 依赖数组：使用 useEffect 时，需要正确管理依赖数组，防止多余的副作用执行或遗漏。 总结 React Hooks 通过利用闭包和 Fiber 架构，使得函数组件能够拥有类似类组件的状态管理和生命周期管理能力，并且通过链表结构跟踪每个 Hook 的状态，从而实现了高效的状态更新和逻辑复用。\n为什么useState 要返回一个数组？ 如果 useState 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净 如果 useState 返回的是对象，在解构对象的时候必须要和 useState 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值 react hook的使用限制有哪些？为什么？ React Hooks 的限制主要是为了保证其运行的稳定性和一致性，这些限制包括：\n只能在函数组件的最顶层使用：Hooks 不能在条件语句、循环、嵌套函数中调用。这是为了保证 Hooks 的调用顺序在每次渲染中都保持一致。React 通过这个限制确保在每次渲染时，Hooks 都能正确地找到对应的 state 和 effect。如果在条件语句或循环中使用，会导致调用顺序的变化，进而导致状态混乱或丢失。\n只能在 React 函数中使用 Hooks：Hooks 不能在普通的 JavaScript 函数中使用，只能在 React 函数组件或自定义 Hook 中使用。这是为了确保 Hooks 的逻辑与 React 渲染流程保持一致，从而让 React 能正确管理组件的状态和副作用。\n自定义 Hook 的命名规范：自定义 Hook 必须以 use 开头，这样做是为了帮助 React 自动区分普通函数和自定义 Hook，便于更好地进行调试和优化。\n这些限制主要是为了维护 React Hooks 的工作机制，使得它们能够高效地追踪状态变化，确保数据的准确性和完整性。同时，这些限制也可以帮助开发者遵循最佳实践，避免代码在渲染过程中出现无法预测的问题。\nuseEffect 和 userLayoutEffect 的区别？ useEffect 和 useLayoutEffect 是 React 中两个用于处理副作用的 Hook，它们的主要区别在于执行时机：\n1. 执行时机 useEffect：在浏览器完成渲染后才会执行。它是一个异步的副作用处理方式，这意味着它不会阻塞浏览器的绘制过程。因此，useEffect 更适合那些不需要在页面渲染之前执行的副作用，例如数据请求、订阅、事件监听等。 useLayoutEffect：在浏览器完成 DOM 变更后、浏览器实际绘制页面之前同步执行。这意味着它会在浏览器绘制之前执行完毕，所以会阻塞渲染。useLayoutEffect 更适合那些需要在 DOM 更新后立即读取或修改 DOM 的情况，例如测量 DOM 大小、获取布局信息、修改样式等。 2. 使用场景 useEffect：适合大多数副作用场景，如获取数据、监听事件、订阅等，因为它不会阻塞浏览器的绘制过程，性能更好。 useLayoutEffect：适用于需要在 DOM 更新后立即执行的操作，例如计算布局、测量 DOM 元素尺寸等，因为它能保证在浏览器绘制前执行完。 3. 性能方面 useEffect 是非阻塞的，性能更好，通常更推荐使用。 useLayoutEffect 是阻塞的，如果大量使用，可能会影响性能。 总结 通常情况下，应该优先使用 useEffect，只有在需要同步执行、并且对布局或 DOM 操作要求严格的场景下，才使用 useLayoutEffect。\nReact hooks 和生命周期的关系？ React Hooks 与类组件生命周期之间存在对应关系，Hooks 提供了一种更灵活、更简洁的方式来处理组件生命周期的逻辑。以下是两者的对应关系：\n1. 初始化阶段 (Mounting) 类组件： constructor() componentDidMount() Hooks： useEffect(() =\u0026gt; { ... }, []) useState() / useReducer() 用于初始化状态 useEffect 带空依赖数组 [] 只在组件挂载时执行，与 componentDidMount 的作用相同。初始化状态则可以通过 useState 或 useReducer 完成。\n2. 更新阶段 (Updating) 类组件： componentDidUpdate(prevProps, prevState) Hooks： useEffect(() =\u0026gt; { ... }, [dependencies]) 在 useEffect 中指定依赖项数组 [dependencies]，当这些依赖项发生变化时，useEffect 就会执行，与 componentDidUpdate 类似。\n3. 卸载阶段 (Unmounting) 类组件： componentWillUnmount() Hooks： useEffect(() =\u0026gt; { return () =\u0026gt; { ... } }, []) 在 useEffect 中返回一个清理函数，且指定空依赖数组 []，与 componentWillUnmount 对应，用于清理副作用，例如取消订阅、清除计时器等。\n4. 额外的生命周期方法 类组件： shouldComponentUpdate(nextProps, nextState): 控制组件是否需要更新 getDerivedStateFromProps(props, state): 根据新的 props 更新状态 getSnapshotBeforeUpdate(prevProps, prevState): 读取更新前的 DOM 状态 Hooks： React.memo：类似于 shouldComponentUpdate，用于性能优化 useEffect 或 useLayoutEffect：可以在特定场景下模拟 getSnapshotBeforeUpdate 的效果 对于 getDerivedStateFromProps，一般可以通过 useEffect 或 useState 来实现类似的逻辑。 总结 Hooks 提供了 useEffect 来覆盖 componentDidMount、componentDidUpdate、componentWillUnmount，使得开发者可以在一个地方处理副作用。 Hooks 让函数组件能够管理状态和副作用，简化了原来类组件的生命周期逻辑，减少了代码的复杂性。 useEffect 和 useLayoutEffect 的区别？ useEffect 和 useLayoutEffect 是 React 中用于处理副作用的两个 Hook，它们的主要区别在于执行时机和使用场景。以下是它们的详细比较：\n1. 执行时机 useEffect： 在浏览器完成绘制后执行。也就是说，useEffect 的回调函数会在 DOM 更新后、浏览器绘制完成后执行。 适合处理不需要阻塞浏览器绘制的副作用，如数据获取、订阅、事件监听等。 1 2 3 4 useEffect(() =\u0026gt; { // 这里的代码在 DOM 更新后执行 console.log(\u0026#39;Effect executed after render\u0026#39;); }, [dependencies]); useLayoutEffect： 在浏览器绘制之前执行。useLayoutEffect 的回调函数会在 DOM 更新后、浏览器绘制之前执行。 适合处理需要在浏览器绘制之前完成的副作用，如读取布局信息、同步 DOM 操作等。 1 2 3 4 useLayoutEffect(() =\u0026gt; { // 这里的代码在 DOM 更新后但在浏览器绘制之前执行 console.log(\u0026#39;Layout effect executed before render\u0026#39;); }, [dependencies]); 2. 性能影响 useEffect：\n由于在浏览器绘制后执行，不会阻塞浏览器的绘制过程，因此对性能影响较小。 适合大多数副作用场景。 useLayoutEffect：\n由于在浏览器绘制之前执行，可能会阻塞浏览器的绘制过程，导致性能下降。 应谨慎使用，尤其是在需要频繁更新的场景中。 3. 使用场景 useEffect：\n数据获取：从 API 获取数据并更新状态。 订阅：设置和清理事件监听器。 动画：在组件更新后启动动画。 useLayoutEffect：\n读取布局信息：在 DOM 更新后立即读取元素的尺寸或位置。 需要同步更新的 DOM 操作：例如，调整元素的样式或位置，确保在浏览器绘制之前完成。 4. 代码示例 使用 useEffect：\n1 2 3 4 5 6 7 8 9 10 11 import React, { useEffect, useState } from \u0026#39;react\u0026#39;; const ExampleComponent = () =\u0026gt; { const [data, setData] = useState(null); useEffect(() =\u0026gt; { fetchData().then(response =\u0026gt; setData(response)); }, []); return \u0026lt;div\u0026gt;{data}\u0026lt;/div\u0026gt;; }; 使用 useLayoutEffect：\n1 2 3 4 5 6 7 8 9 10 11 12 import React, { useLayoutEffect, useRef } from \u0026#39;react\u0026#39;; const LayoutExample = () =\u0026gt; { const divRef = useRef(null); useLayoutEffect(() =\u0026gt; { const height = divRef.current.getBoundingClientRect().height; console.log(\u0026#39;Height:\u0026#39;, height); // 在浏览器绘制之前读取高度 }, []); return \u0026lt;div ref={divRef}\u0026gt;Hello, World!\u0026lt;/div\u0026gt;; }; 总结 useEffect：在浏览器绘制后执行，适合大多数副作用场景，性能影响较小。 useLayoutEffect：在浏览器绘制之前执行，适合需要同步更新的副作用，可能会影响性能。 在选择使用哪个 Hook 时，通常推荐优先使用 useEffect，只有在确实需要在浏览器绘制之前执行某些操作时，才使用 useLayoutEffect。\n说一下react hooks 的执行过程，当它遇到钩子函数（原生钩子以及自定义钩子）时，它会重新执行一遍吗？ 在 React 中，Hooks 组件的执行过程涉及多个步骤，特别是在使用 useEffect 和自定义 Hooks 时。以下是详细的执行过程说明：\n1. 组件的初始渲染 函数组件调用：当组件首次渲染时，React 会调用该函数组件。 执行 Hooks：在组件内部，React 会按顺序执行所有的 Hooks，包括 useState、useEffect 和自定义 Hooks。 1 2 3 4 5 6 7 8 9 const MyComponent = () =\u0026gt; { const [count, setCount] = useState(0); // 初始化状态 useEffect(() =\u0026gt; { console.log(\u0026#39;Effect executed on mount\u0026#39;); }, []); // 仅在组件挂载时执行 return \u0026lt;div\u0026gt;{count}\u0026lt;/div\u0026gt;; }; 2. 组件的更新 状态或属性变化：当组件的状态（通过 setState）或属性发生变化时，React 会重新调用该组件的函数。 重新执行 Hooks：每次组件重新渲染时，所有的 Hooks 都会被重新执行。这意味着 useState 会返回当前状态和更新函数，而 useEffect 的回调函数会在适当的时机执行。 3. useEffect 的执行 初始渲染：在组件首次渲染后，React 会在 DOM 更新完成后执行 useEffect 中的回调函数。 依赖数组：如果 useEffect 的依赖数组为空（[]），则回调函数只会在组件挂载时执行一次。如果依赖数组中有变量，只有当这些变量发生变化时，useEffect 的回调函数才会重新执行。 1 2 3 useEffect(() =\u0026gt; { console.log(\u0026#39;Effect executed on count change\u0026#39;); }, [count]); // 仅在 count 变化时执行 4. 自定义 Hooks 的执行 自定义 Hooks：自定义 Hooks 是一个函数，可以调用其他 Hooks。每次组件重新渲染时，自定义 Hooks 也会被重新执行。 1 2 3 4 5 6 7 8 9 10 const useCustomHook = () =\u0026gt; { const [value, setValue] = useState(0); // 其他逻辑 return [value, setValue]; }; const MyComponent = () =\u0026gt; { const [customValue, setCustomValue] = useCustomHook(); // 自定义 Hook // 组件逻辑 }; 5. 清理副作用 清理函数：如果 useEffect 返回一个清理函数，React 会在组件卸载或依赖项变化时调用该清理函数。这使得可以在组件卸载时清理副作用（如取消订阅、清除定时器等）。 1 2 3 4 5 6 7 8 9 useEffect(() =\u0026gt; { const timer = setTimeout(() =\u0026gt; { console.log(\u0026#39;Timer executed\u0026#39;); }, 1000); return () =\u0026gt; { clearTimeout(timer); // 清理定时器 }; }, []); 6. 组件卸载 卸载过程：当组件从 UI 中移除时，React 会调用 useEffect 中的清理函数（如果有），并且组件的状态和 Hooks 会被清除。 总结 每次组件重新渲染时，所有的 Hooks（包括 useEffect 和自定义 Hooks）都会被重新执行。 useEffect 的回调函数在组件挂载后执行，并根据依赖数组的变化决定是否重新执行。 自定义 Hooks 也会在每次渲染时被重新调用，允许在多个组件之间共享逻辑。 清理函数在组件卸载或依赖项变化时执行，确保副作用的正确管理。 这种机制使得 React 的 Hooks 组件能够灵活地管理状态和副作用，同时保持代码的简洁性和可读性。\n","date":"2020-09-09T00:00:00Z","permalink":"https://trinyoung.github.io/interview/p/test-chinese/","title":"react hooks 面试题2"},{"content":"1. vue 中keepAlive 的原理 在 Vue 中，keep-alive 是一个内置组件，用于缓存不活动的组件实例，从而在它们重新激活时避免重新渲染。这个功能特别适合需要在不同视图之间切换时保留组件状态的场景，如路由组件切换时保留表单输入数据、滚动位置等。\nkeep-alive 的工作原理 keep-alive 组件通过以下机制实现组件的缓存和复用：\n组件缓存：\n当某个组件被包裹在 keep-alive 中，并且被移除（如路由切换、条件渲染），keep-alive 不会销毁这个组件的实例，而是将其缓存起来。 当该组件再次被激活时，keep-alive 会直接从缓存中取出组件实例，而不是重新创建和渲染组件。这样可以节省性能开销。 缓存管理：\nkeep-alive 通过 cache 和 keys 属性来管理缓存的组件实例。 cache 是一个对象，存储了所有被缓存的组件实例。它的键是组件的 key 或 cid（组件的唯一标识符）。 keys 是一个数组，记录了缓存中的组件键的顺序，keep-alive 通过这个顺序来决定哪个组件需要被缓存或移除。 生命周期钩子：\n被 keep-alive 缓存的组件实例不会触发 created、mounted 等生命周期钩子。但会新增两个生命周期钩子： activated: 当组件从缓存中激活时触发。 deactivated: 当组件被缓存且移除时触发。 keep-alive 的常用属性 include：允许的组件名（或正则表达式），只有匹配的组件才会被缓存。 exclude：排除的组件名（或正则表达式），匹配的组件不会被缓存。 max：缓存的最大组件实例数目，超过这个数目时，最先缓存的组件实例将被移除。 使用示例 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;keep-alive include=\u0026#34;MyComponent\u0026#34; max=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/keep-alive\u0026gt; \u0026lt;/template\u0026gt; 简单的示意代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 这是 keep-alive 组件内部的简化示意 class KeepAlive { constructor() { this.cache = Object.create(null); // 用于缓存组件实例 this.keys = []; // 用于记录缓存的键的顺序 } cacheVNode(key, vnode) { this.cache[key] = vnode; this.keys.push(key); } pruneCacheEntry(key) { const cachedVNode = this.cache[key]; if (cachedVNode) { cachedVNode.componentInstance.$destroy(); // 销毁实例 delete this.cache[key]; this.keys.splice(this.keys.indexOf(key), 1); } } } 总结 keep-alive 的缓存是存储在 Vue 的内存中的，而不是存储在浏览器的本地存储或其他持久化存储中。具体来说，keep-alive 组件实例中维护的 cache 对象和 keys 数组，负责管理和存储这些缓存的组件实例。当需要重新渲染组件时，Vue 会从 cache 中取出对应的 VNode，从而避免重复的组件实例创建和渲染。\n2. vue 中diff算法的原理 Vue 中的 diff 算法是其虚拟 DOM (VNode) 实现的核心部分，用于高效地更新视图。它的基本思想是通过比较新旧两个虚拟 DOM 树，找出最小的变更集，然后在真实 DOM 上进行最小量的操作，从而优化性能。\nDiff 算法的核心思想 同层比较：\nVue 的 diff 算法只会对比同层级的节点，而不会跨层级比较。因为跨层级的移动或者比较成本非常高，所以 Vue 的 diff 算法会假设不同层级的 DOM 结构差异不会太大。 双端比较：\nVue 使用了一种双端比较算法，从前后两端同时进行比较，从而提高了效率。具体步骤如下： 从头开始比较：首先比较新旧虚拟 DOM 树的第一个节点，如果相同就继续向下比较，如果不同则停止。 从尾开始比较：接着从两棵树的尾部开始比较，如果相同则继续向前比较，如果不同则停止。 如果中间有差异：Vue 会尝试通过查找旧节点中的 key 来确认新节点是否在旧节点中已经存在，如果存在则移动节点，如果不存在则创建新节点。 同类型节点的更新：\n如果两个节点是相同类型（即标签相同），Vue 会继续比较他们的属性和子节点，找出需要更新的地方。 删除、创建、移动节点：\n删除：如果旧虚拟 DOM 树中的某个节点在新虚拟 DOM 树中不存在，那么这个节点会被删除。 创建：如果新虚拟 DOM 树中出现了旧虚拟 DOM 树中没有的节点，Vue 会创建这个新节点。 移动：如果发现相同的节点在新旧虚拟 DOM 树中的位置不同，Vue 会移动这个节点。 优化：通过 key 提升性能：\nVue 建议为列表中的节点提供唯一的 key，这样可以使得 Vue 在 diff 的过程中能更准确地找到对应节点，提高更新效率。 如果没有 key，Vue 会采用一种“就地复用”的策略，即如果两个节点是同一类型的，它们会被认为是同一个节点，即使它们在实际内容上不同。 Diff 算法的具体步骤 假设有两棵虚拟 DOM 树：oldVNode 和 newVNode。\n比较根节点：\n首先比较 oldVNode 和 newVNode 的根节点，如果节点类型不同，直接替换整个节点。 比较子节点：\n如果根节点类型相同，则进入子节点的比较。如果子节点有 key 属性，会基于 key 进行比对，否则基于节点的位置和类型。 同层比较：\n在同一层级中，Vue 使用双端比较法（先从头到尾，再从尾到头）找出可以复用的节点。 递归更新：\n对于每一个节点，Vue 递归地对子节点进行相同的 diff 操作。 处理边界情况：\n如果旧节点比新节点多，Vue 会删除多余的旧节点。 如果新节点比旧节点多，Vue 会创建新的节点并插入。 Diff 算法的复杂度 在最理想的情况下，Vue 的 diff 算法的复杂度为 O(n)，其中 n 是节点数量。但如果节点结构差异较大，可能会接近 O(n^2)，因此 Vue 强烈建议开发者在有序列表中使用 key 以提升 diff 算法的性能。\n总结 Vue 的 diff 算法通过同层比较、双端比较以及递归地处理子节点，来确保 DOM 更新的最小化操作。合理使用 key 可以进一步提升 diff 算法的效率，从而在真实 DOM 中高效地反映虚拟 DOM 的变化。\n3. vue 的核心概念是什么？ 1. 数据驱动视图 Vue 的核心理念之一是“数据驱动视图”，即视图层是由数据层驱动的。\n响应式数据绑定：\nVue 采用双向数据绑定（Two-Way Data Binding），通过 data 选项定义的数据属性和视图之间建立自动的绑定关系。任何对数据的更新都会自动反映在视图中，而用户在视图中的操作也能即时更新数据。 Vue 的响应式系统是基于 Object.defineProperty（Vue 2）或 Proxy（Vue 3）实现的。当数据发生变化时，Vue 的依赖追踪系统会自动侦测到并触发相应的视图更新。 声明式渲染：\nVue 使用模板语法，让开发者可以声明式地定义 UI。模板中的表达式会动态绑定到 Vue 实例中的数据，开发者只需专注于数据本身，而无需直接操作 DOM。 这种方式降低了操作 DOM 的复杂性，提升了开发效率和代码的可维护性。 2. 组件化 “组件化”是 Vue 的另一核心思想，它允许开发者将应用拆分为独立、可复用的小块（组件），每个组件负责特定的功能或 UI 部分。\n组件封装：\n每个组件包含了自己的模板、逻辑和样式，使得组件内部的实现细节对外部是封装的。这样，开发者可以轻松地维护和复用组件，减少代码重复。 组件组合：\nVue 应用通常是通过多个组件的组合构建起来的。通过父子组件的组合和传递 props 及事件，可以构建出复杂的用户界面。 单文件组件 (SFC)：\nVue 提供了单文件组件的开发方式（.vue 文件），将模板、逻辑和样式集中在一个文件中。SFC 使得组件的开发、维护和复用变得更加方便。 3. 其他核心概念 除了以上两大核心思想，Vue 还具备以下重要的核心概念：\n渐进式框架：\nVue 是一个渐进式框架，这意味着你可以根据需求从轻量级的视图库逐步扩展到功能完备的前端框架。Vue 可以与其他库或现有项目轻松集成，也可以单独用于构建复杂的单页面应用 (SPA)。 生态系统：\nVue 的生态系统非常丰富，包括 Vue Router（路由管理）、Vuex（状态管理）等，这些工具帮助开发者在不同的场景下有效管理应用的复杂性。 虚拟 DOM：\nVue 使用虚拟 DOM 技术来提升性能。通过比较虚拟 DOM 树的差异（diff），Vue 可以智能地决定最小化的 DOM 操作，从而高效地更新视图。 总结 Vue 的核心思想是通过数据驱动视图，结合组件化的方式，帮助开发者构建高效、可维护、可复用的用户界面。Vue 的响应式数据系统和渐进式特性，使得它既适合小型项目，也能胜任复杂的单页面应用。\n4. vue 的双向绑定的原理是什么？vue2和vue3的区别是什么？ Vue 的数据双向绑定是 Vue 框架的核心特性之一，它使得数据和视图之间保持同步，即数据的变化会自动反映到视图上，而用户在视图上的操作也会自动更新数据。Vue 2 和 Vue 3 在实现数据双向绑定的方式上有一些不同，下面我将分别介绍它们的原理及差异。\nVue 2 的数据双向绑定原理 Vue 2 的数据双向绑定主要依赖于 Object.defineProperty，通过劫持对象属性的 getter 和 setter 来实现数据的响应式。\n1. Observer 监听器 Vue 2 中，当一个 Vue 实例被创建时，Vue 会遍历 data 对象中的所有属性，并使用 Object.defineProperty 将这些属性转为 getter 和 setter。 通过这些 getter 和 setter，Vue 可以在数据被访问时（通过 getter）或修改时（通过 setter）进行额外的操作，比如依赖收集和派发更新。 2. Dep 和 Watcher Dep：每个被观察的属性（即每个 data 中的属性）都有一个依赖管理器（Dep），负责收集依赖于这个属性的所有“观察者” (Watcher)。 Watcher：Watcher 是一个观察者对象，负责监听属性的变化。当属性发生变化时，Watcher 会触发视图的更新。 3. 数据流动 当组件的模板被渲染时，模板中的数据会触发属性的 getter，从而触发依赖收集（Dep 将 Watcher 收集起来）。 当数据发生变化时（即属性的 setter 被触发），Vue 会通知对应的 Watcher，Watcher 随后通知视图进行重新渲染。 局限性 Vue 2 的实现方式基于 Object.defineProperty，它无法直接监听数组的变化，也无法直接监听对象属性的添加和删除，因此 Vue 2 需要通过一些特殊方法（如 Vue.set、Vue.delete）来处理这些情况。 Vue 3 的数据双向绑定原理 Vue 3 引入了 Proxy 对象，取代了 Vue 2 中的 Object.defineProperty，以实现更为强大和灵活的数据双向绑定。\n1. Proxy 与 Reflect Vue 3 中，响应式数据的核心是 Proxy，它能够直接拦截对象的所有操作，包括读取、写入、删除属性等。这意味着 Vue 3 能够监听数组的变化以及对象属性的动态添加和删除。 Vue 3 使用 Proxy 代理了 data 对象，并通过 Reflect 来处理代理对象的默认行为。 2. Reactivity 模块 Vue 3 的响应式系统是基于一个独立的 Reactivity 模块实现的，这个模块包含了 reactive、ref、computed 等 API，允许开发者以更加灵活的方式创建响应式数据。 通过 reactive，Vue 3 可以将一个普通对象转为响应式对象，类似于 Vue 2 中的 data。 3. 依赖追踪和触发 Vue 3 的依赖追踪和触发更新机制与 Vue 2 类似，都是通过依赖收集（依赖于数据的组件或方法会被收集）和触发更新（当数据改变时通知依赖的组件或方法进行更新）来实现的。 由于 Proxy 的强大功能，Vue 3 可以更精细地追踪变化，避免了 Vue 2 中的一些局限性，比如对数组操作的监测问题。 Vue 2 与 Vue 3 的主要区别 实现方式：\nVue 2 使用 Object.defineProperty 实现数据双向绑定，Vue 3 使用 Proxy 来实现更为强大和灵活的响应式系统。 响应式系统的灵活性：\nVue 3 的 Proxy 可以直接监听数组的变化、对象属性的添加和删除等操作，避免了 Vue 2 的局限性。 Vue 3 的响应式 API（如 reactive、ref）提供了更多的控制和灵活性。 性能：\nVue 3 的响应式系统在性能上有了很大的提升，特别是在大规模数据操作和复杂的组件树结构中，Vue 3 表现得更为高效。 代码结构和模块化：\nVue 3 的响应式系统是一个独立的模块，允许更好的树摇优化（tree-shaking），减小打包体积。 总结 Vue 的数据双向绑定是通过数据的响应式系统实现的，Vue 2 使用 Object.defineProperty，而 Vue 3 则使用 Proxy 来实现。Vue 3 的实现方式更加灵活和强大，解决了 Vue 2 中的一些局限性，同时也带来了更好的性能和开发体验。\n5. vue 的生命周期有哪些？ Vue 的生命周期钩子函数是指在 Vue 实例的各个不同阶段执行的函数。这些钩子函数允许开发者在 Vue 实例的不同生命周期阶段执行自定义的代码。Vue 2 和 Vue 3 的生命周期钩子基本一致，以下是主要的生命周期钩子函数及其触发时机：\n1. 创建阶段（Creation Phase） beforeCreate：实例初始化之后，数据观测 (data observer) 和事件配置还未完成。在这个阶段，data 和 props 还没有被初始化，因此在这个钩子中无法访问 data 和 props。\ncreated：实例创建完成，完成数据观测、属性与方法的初始化，data、props 等都可以访问。此时尚未挂载到 DOM 中，也没有生成 $el。\n2. 挂载阶段（Mounting Phase） beforeMount：在挂载开始之前被调用，相关的 render 函数首次被调用。在这个阶段，虚拟 DOM 已经创建，但尚未渲染到实际的 DOM 上。\nmounted：实例挂载到 DOM 后调用，此时 el 被新创建的 vm.$el 替换。此时组件已被挂载到页面上，DOM 操作可以在这里进行。\n3. 更新阶段（Updating Phase） beforeUpdate：响应式数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁 (patch) 之前。在这个钩子中，可以访问到更新前的 DOM。\nupdated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。此时组件 DOM 已经更新，因此可以执行基于新 DOM 的操作。\n4. 销毁阶段（Destruction Phase） beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。\ndestroyed：实例销毁后调用。调用后，Vue 实例的所有指令绑定和事件监听器都会被解除，所有子实例也会被销毁。\n5. Vue 3 特有的生命周期钩子 Vue 3 引入了与组合式 API（Composition API）一起使用的生命周期钩子函数，这些函数与 Vue 2 中的钩子作用相同，但命名更具可读性，并且使用更灵活。\nonBeforeMount：等同于 Vue 2 的 beforeMount。 onMounted：等同于 Vue 2 的 mounted。 onBeforeUpdate：等同于 Vue 2 的 beforeUpdate。 onUpdated：等同于 Vue 2 的 updated。 onBeforeUnmount：等同于 Vue 2 的 beforeDestroy。 onUnmounted：等同于 Vue 2 的 destroyed。 这些钩子函数可以在 Vue 3 的组合式 API 中使用，例如在 setup 函数中调用。\n总结 Vue 的生命周期提供了一个从创建、挂载、更新到销毁的完整流程的钩子函数，让开发者可以在每个关键节点执行相应的操作。了解和使用这些钩子函数，可以帮助更好地控制组件的行为，处理复杂的逻辑或优化性能。\n6. vue 的组件通信方式有哪些？ 在 Vue 中，组件之间的通信方式有多种，具体选择哪种方式取决于组件之间的关系（如父子关系、兄弟关系）以及数据流的复杂度。以下是 Vue 组件之间常见的通信方式：\n1. 父子组件通信 1.1 Props 传递 父组件通过 props 向子组件传递数据。这是 Vue 中最常用的通信方式之一。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- 父组件 --\u0026gt; \u0026lt;ChildComponent :message=\u0026#34;parentMessage\u0026#34; /\u0026gt; \u0026lt;!-- 子组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ message }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#39;message\u0026#39;] } \u0026lt;/script\u0026gt; 1.2 Event 触发 子组件可以通过 $emit 触发事件，父组件监听事件来接收数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!-- 子组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;Send Message\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { sendMessage() { this.$emit(\u0026#39;message-sent\u0026#39;, \u0026#39;Hello from child\u0026#39;); } } } \u0026lt;/script\u0026gt; \u0026lt;!-- 父组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;ChildComponent @message-sent=\u0026#34;receiveMessage\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { receiveMessage(msg) { console.log(msg); } } } \u0026lt;/script\u0026gt; 2. 兄弟组件通信 2.1 通过父组件作为中介 兄弟组件可以通过父组件传递数据。例如，一个兄弟组件通过 Event 传递数据给父组件，父组件再将数据通过 Props 传递给另一个兄弟组件。\n2.2 事件总线 (Event Bus) 创建一个空的 Vue 实例作为事件总线，兄弟组件可以通过这个总线来通信。不过在 Vue 3 中，建议使用其他方式替代事件总线。\n1 2 3 4 5 6 7 8 9 10 11 // eventBus.js import Vue from \u0026#39;vue\u0026#39;; export const EventBus = new Vue(); // 兄弟组件A EventBus.$emit(\u0026#39;event-name\u0026#39;, data); // 兄弟组件B EventBus.$on(\u0026#39;event-name\u0026#39;, (data) =\u0026gt; { console.log(data); }); 2.3 Vuex (状态管理) 在复杂应用中，可以使用 Vuex 进行状态管理。兄弟组件可以通过 Vuex 共享状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // store.js export const store = new Vuex.Store({ state: { message: \u0026#39;\u0026#39; }, mutations: { setMessage(state, msg) { state.message = msg; } } }); // 兄弟组件A this.$store.commit(\u0026#39;setMessage\u0026#39;, \u0026#39;Hello from A\u0026#39;); // 兄弟组件B computed: { message() { return this.$store.state.message; } } 3. 跨层级组件通信 3.1 Provide 和 Inject Provide 和 Inject 允许父组件向任意层级的后代组件提供数据，而不必通过 Props 层层传递。\n1 2 3 4 5 6 7 8 9 10 11 // 父组件 export default { provide: { message: \u0026#39;Hello World\u0026#39; } } // 任意层级的子组件 export default { inject: [\u0026#39;message\u0026#39;] } 3.2 Vuex 同样地，Vuex 也可以用于跨层级的组件通信，通过集中管理状态来实现跨层级的数据共享。\n4. 其他通信方式 4.1 $attrs 和 $listeners 父组件向子组件传递属性和事件，适用于高阶组件（Higher-order components）。\n4.2 $parent 和 $children 通过访问组件实例的 $parent 和 $children 来通信，但这种方式不推荐使用，因为它会导致组件之间的耦合性增加。\n4.3 Ref 和 $refs 通过 ref 获取子组件的实例，从而访问或调用子组件的方法和属性。\n1 2 3 4 5 6 \u0026lt;!-- 父组件 --\u0026gt; \u0026lt;ChildComponent ref=\u0026#34;child\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; this.$refs.child.someMethod(); \u0026lt;/script\u0026gt; 总结 Vue 提供了多种组件通信方式，适用于不同的场景和复杂度。在选择通信方式时，应考虑组件之间的关系、数据流的复杂度以及应用的规模，尽量保持代码的简洁性和可维护性。\n7. vue 的路由模式有哪些？ Vue 的路由模式是指在 Vue 应用中定义路由的方式，包括 hash 模式和 history 模式。\n1. Hash 模式 Hash 模式是 Vue 路由的默认模式，使用 URL 中的哈希值（#）来表示路由。例如，访问 URL_ADDRESS 会将 #/about` 作为哈希值，并将其作为路由。\n1 2 3 4 5 6 7 8 9 // 路由配置 const router = new VueRouter({ routes: [ { path: \u0026#39;/\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, component: About } ] }) // 访问 URL_ADDRESS/#/about 优点 兼容性好，支持所有浏览器。 易于分享，因为 URL 中没有 #，因此可以轻松分享链接。 缺点 不利于 SEO，因为哈希值不会被包含在搜索引擎的索引中。 不利于后端路由，因为哈希值不会被发送到服务器。 不利于前端路由，因为哈希值的变化不会触发页面的刷新。 2. History 模式 History 模式使用 HTML5 的 History API 来实现路由，它通过修改 URL 来实现路由跳转，从而避免了使用哈希值。\n1 2 3 4 5 6 7 8 9 10 // 路由配置 const router = new VueRouter({ mode: \u0026#39;history\u0026#39;, routes: [ { path: \u0026#39;/\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, component: About } ] }) // 访问 URL_ADDRESS/about 优点 易于分享，因为 URL 中没有 #，因此可以轻松分享链接。 支持后端路由，因为服务器可以根据 URL 来返回相应的页面。 支持前端路由，因为 URL 的变化会触发页面的刷新。 缺点 兼容性稍差，需要浏览器支持 HTML5 的 History API。 不利于 SEO，因为 URL 中没有 #，搜索引擎会认为这是一个普通的 URL，而不是锚点。 总结 Vue 的路由模式包括 hash 模式和 history 模式。hash 模式使用 URL 中的哈希值（#）来表示路由，而 history 模式使用 HTML5 的 History API 来实现路由。选择哪种模式取决于应用的需求和使用场景。\n8. vue 的路由守卫有哪些？ Vue 的路由守卫是指在路由跳转过程中执行的钩子函数，可以用来实现路由的权限控制、数据预加载等功能。Vue 提供了多种路由守卫，包括全局守卫、路由独享守卫和组件内守卫。\n1. 全局守卫 全局守卫是指在路由跳转过程中，无论路由是跳转到哪个路由，都会执行的钩子函数。\n1 2 3 4 5 6 7 8 9 10 // 全局前置守卫 router.beforeEach((to, from, next) =\u0026gt; { // 在跳转到目标路由之前执行的操作 next(); }); // 全局后置守卫 router.afterEach((to, from) =\u0026gt; { // 在跳转到目标路由之后执行的操作 }); 2. 路由独享守卫 路由独享守卫是指在特定的路由上执行的钩子函数，可以用来实现路由的权限控制、数据预加载等功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 路由独享前置守卫 const router = new VueRouter({ routes: [ { path: \u0026#39;/about\u0026#39;, component: About, beforeEnter: (to, from, next) =\u0026gt; { // 在跳转到 /about 路由之前执行的操作 next(); } } ] }); // 路由独享后置守卫 const router = new VueRouter({ routes: [ { path: \u0026#39;/about\u0026#39;, component: About, afterEnter: (to, from) =\u0026gt; { // 在跳转到 /about 路由之后执行的操作 } } ] }); 3. 组件内守卫 组件内守卫是指在组件内定义的钩子函数，可以用来实现组件内的权限控制、数据预加载等功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 组件内前置守卫 const Foo = { template: `\u0026lt;div\u0026gt;Foo\u0026lt;/div\u0026gt;`, beforeRouteEnter (to, from, next) { // 在跳转到该组件路由之前执行的操作 next(); } } // 组件内后置守卫 const Foo = { template: `\u0026lt;div\u0026gt;Foo\u0026lt;/div\u0026gt;`, beforeRouteLeave (to, from, next) { // 在离开该组件路由之前执行的操作 next(); } } 4. 路由元信息 路由元信息是指在路由配置中定义的额外信息，可以用来实现路由的权限控制、数据预加载等功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 路由配置 const router = new VueRouter({ routes: [ { path: \u0026#39;/about\u0026#39;, component: About, meta: { requiresAuth: true, // 需要登录权限 requiresAdmin: true // 需要管理员权限 } } ] }); // 路由守卫 router.beforeEach((to, from, next) =\u0026gt; { if (to.meta.requiresAuth \u0026amp;\u0026amp; !isAuthenticated()) { // 如果需要登录权限，且用户未登录，则跳转到登录页面 next({ path: \u0026#39;/login\u0026#39; }); } else if (to.meta.requiresAdmin \u0026amp;\u0026amp; !isAdmin()) { // 如果需要管理员权限，且用户不是管理员，则跳转到 403 页面 next({ path: \u0026#39;/403\u0026#39; }); } else { // 如果不需要权限或权限验证通过，则继续跳转 next(); } }); 5. 导航守卫的执行顺序 导航守卫的执行顺序是：全局前置守卫 -\u0026gt; 路由独享前置守卫 -\u0026gt; 组件内前置守卫 -\u0026gt; 全局后置守卫 -\u0026gt; 路由独享后置守卫 -\u0026gt; 组件内后置守卫。\n6. 总结 Vue 的路由守卫提供了多种方式来实现路由的权限控制、数据预加载等功能。全局守卫、路由独享守卫和组件内守卫可以根据需要进行配置，路由元信息可以用来定义路由的额外信息。导航守卫的执行顺序是：全局前置守卫 -\u0026gt; 路由独享前置守卫 -\u0026gt; 组件内前置守卫 -\u0026gt; 全局后置守卫 -\u0026gt; 路由独享后置守卫 -\u0026gt; 组件内后置守卫。\n9. vue 的路由懒加载有哪些方式？ Vue 的路由懒加载是指在路由配置中使用动态导入的方式来加载路由组件，从而减少应用的初始加载时间。Vue 提供了多种方式来实现路由懒加载，包括异步组件、异步路由组件和异步路由。\n1. 异步组件 异步组件是指在路由配置中使用 import() 函数来动态导入路由组件，从而实现路由懒加载。\n1 2 3 4 5 6 7 8 9 // 路由配置 const router = new VueRouter({ routes: [ { path: \u0026#39;/about\u0026#39;, component: () =\u0026gt; import(\u0026#39;./views/About.vue\u0026#39;) } ] }); 2. 异步路由组件 异步路由组件是指在路由配置中使用 component 属性来定义异步路由组件，从而实现路由懒加载。\n1 2 3 4 5 6 7 8 9 // 路由配置 const router = new VueRouter({ routes: [ { path: \u0026#39;/about\u0026#39;, component: () =\u0026gt; import(\u0026#39;./views/About.vue\u0026#39;) } ] }); 3. 异步路由 异步路由是指在路由配置中使用 children 属性来定义异步路由，从而实现路由懒加载。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 路由配置 const router = new VueRouter({ routes: [ { path: \u0026#39;/about\u0026#39;, component: About, children: [ { path: \u0026#39;child1\u0026#39;, component: () =\u0026gt; import(\u0026#39;./views/Child1.vue\u0026#39;) }, { path: \u0026#39;child2\u0026#39;, component: () =\u0026gt; import(\u0026#39;./views/Child2.vue\u0026#39;) } ] } ] }); 10. vue 路由的原理是什么？ 创建的页面路由会与该页面形成一个路由表（key value形式，key为该路由，value为该路由对应的页面组件）； vue-router 会监听浏览器地址栏的变化，并将地址栏的值与路由表进行匹配，匹配成功后，将对应的页面组件渲染到页面中； 然而当浏览器的中的路径发生变化时，它会向服务器请求资源，为了避免这种情况，vue 采用了两种方式来避免这种情况的发生： hash 和 history； hash 模式：hash 模式是通过在 URL 的末尾添加一个哈希值（#）来实现的，例如：`URL_ADDRESS URL 中的哈希值发生变化时，浏览器不会向服务器发送请求，而是通过 JavaScript 来处理哈希值的变化，从而实现页面的跳转。 history 模式：利用了pushState() 和replaceState() 方法，实现往history中添加新的浏览记录、或替换对应的浏览记录。但是设置了history模式，需要 11. vue3 中的reactive 和 ref 的区别？ 1. 数据类型 ref主要用于创建基本数据类型的响应式数据（如字符串，数字，布尔值等），也可以用来包装一个引用类型的数据（如对象或数组）。当使用 ref 包装数据时，访问或修改这个数据需要通过 .value 属性。 reactive 则直接将一个对象或者数据变成响应式的，不需要通过 .value 属性访问或修改。可以直接使用对象属性或数组方法。 2. 追踪依赖 使用 ref 创建的响应式数据，内部会转换成一个对象，并且添加了一个 .value 属性。这意味着在模板中或者计算属性中使用它时，需要以 .value 的形式来访问。 reactive 直接返回原始对象，因此可以像操作普通对象一样操作它，这使得它在处理复杂数据结构时更为方便。 3. 深层响应式 ref 只能包装一层数据，如果要包装多层数据，需要使用 ref 包装每层数据，例如：ref({a:1,b:{c:2}})。 reactive 默认会递归地让对象内部的所有属性都变成响应式的，即它是深层响应式的。 4. 性能考虑 对于大量的对象或复杂的嵌套数据结构，使用 reactive 可能会更高效，因为它避免了 ref 需要多次调用 .value 的问题。 对于简单的数据，如字符串、数字、布尔值等，使用 ref 可能更方便，因为它不需要额外的开销。ref 更适合单个值或简单数据结构的响应式处理。 5. 使用场景 ref 更适合用于那些会被用在不同作用域中的数据，或者是需要在组件之间共享的状态管理。 reactive 更适合用于那些需要深度响应式处理的数据，例如对象和数组等。 总结来说 总结来说，选择 ref 还是 reactive 主要看具体的应用场景和个人偏好。对于简单的值或者需要在多个组件间共享的状态，ref 可能更加合适；而对于复杂的对象结构或者组件内部的状态管理，reactive 通常更加方便。\n12. vue3 中的reactive 是如何实现的？ 在 Vue 3 中，reactive 是通过 Proxy 对象来实现的。当使用 reactive 创建一个对象时，Vue 会创建一个 Proxy 对象，并将其作为返回值。这个 Proxy 对象将拦截对对象的所有操作，包括读取和写入属性，并通过调用对应的响应式函数来处理。这样，当我们访问或修改这个对象的属性时，Vue 会自动更新视图。\n13. vue3 中的ref 是如何实现的？ 在 Vue 3中，ref 是通过 createRef 函数来实现的。这个函数接受一个参数，这个参数可以是一个基本数据类型（如字符串、数字、布尔值等）或者是一个对象。如果参数是一个对象，那么 createRef 将返回一个对象，该对象有一个 .value 属性，用于访问或修改原始对象。如果参数是一个基本数据类型，那么 createRef 将返回一个对象，该对象有一个 .value 属性，用于访问或修改原始数据。\n14. vue2 中，数据双向绑定为什么使用的Object.defineProperty 而不是Object.defineProperties? 主要原因在于以下几个方面：\n递归劫持 vs 单次批量定义 在 Vue 2 的响应式系统中，不仅仅是对对象的顶层属性进行劫持，还需要递归地劫持嵌套的对象属性。例如，对于一个深层嵌套的对象，Vue 2 需要递归遍历每一层属性，对每个属性都单独进行 Object.defineProperty 操作。这种递归操作要求灵活性，因为 Vue 不仅要处理简单对象，还要处理数组、嵌套对象等复杂结构。 Object.defineProperty 允许逐个属性地进行递归劫持，这使得 Vue 可以处理每个属性、每一层级的递归操作。 Object.defineProperties 则是一次性定义多个属性，缺少了递归的机制。如果使用 Object.defineProperties，当一个属性是嵌套对象时，无法方便地递归对嵌套属性进行响应式处理。 2. 数组和对象的特殊处理 Vue 2 对数组和对象的响应式处理方式不同。Vue 2 使用 Object.defineProperty 来对对象的属性进行拦截，但对数组的操作（比如 push、pop 等方法）则是通过函数重写的方式来进行劫持。如果使用 Object.defineProperties，在处理数组时并不适用。\n灵活性 Object.defineProperty 的逐个属性劫持方法非常灵活，可以在处理不同类型的数据结构（比如数组、对象、普通数据类型）时进行细粒度的控制。例如，如果一个属性是对象，Vue 会递归进行深层的劫持；而如果一个属性是原始类型（比如 number 或 string），Vue 就不会递归。这种灵活的处理方式在 Vue 的数据响应式设计中是非常关键的。\n性能考虑 虽然 Object.defineProperties 允许一次性定义多个属性，但 Vue 的数据响应式系统需要对每一个属性进行深度处理。如果使用 Object.defineProperties，在递归嵌套对象时，依然需要在每层都调用它，这会增加性能上的开销。相反，Object.defineProperty 可以让 Vue 更加精细化地控制每个属性的处理和递归。\n每个属性的特殊拦截逻辑 虽然大部分属性的 getter 和 setter 逻辑是一样的，但 Vue 在某些情况下需要对特定属性进行特殊处理。比如对于数组的某些变更方法（如 push、pop），Vue 需要重写这些方法，以确保数组变更能被检测到。这种情况下，Object.defineProperty 逐个属性地定义 getter 和 setter 更加灵活。\n总结 Vue 2 使用 Object.defineProperty 而不是 Object.defineProperties，是因为 Vue 的响应式系统需要递归处理深层嵌套的对象，还要处理不同类型的数据结构（比如数组）。Object.defineProperty 可以逐个属性地进行递归、灵活地处理嵌套对象和数组变更。而 Object.defineProperties 虽然允许一次性定义多个属性，但在 Vue 这样的响应式系统中不具备足够的灵活性，也无法处理递归的复杂场景。\n所以，Vue 选择 Object.defineProperty 主要是出于灵活性、递归深层嵌套处理和性能上的考虑。\n15. proxy 相对于 Object.defineProperty 有哪些优势？ Proxy 相对于 Object.defineProperty 确实有许多优势。让我们详细比较一下：\n更全面的拦截能力：\nProxy 可以拦截多达 13 种不同的基本操作，包括属性查找、赋值、删除、函数调用等。 Object.defineProperty 主要用于拦截属性的读取（get）和设置（set）操作。 数组操作：\nProxy 可以直接监听数组的变化，包括通过索引设置元素、修改数组长度等操作。 Object.defineProperty 无法直接监听数组索引和长度的变化，需要额外的包装和处理。 动态属性：\nProxy 可以监听整个对象，包括新添加的属性。 Object.defineProperty 只能监听对象的已存在属性，新添加的属性需要额外处理。 性能：\n对于大型对象，Proxy 可能会有更好的性能，因为它不需要递归遍历对象的所有属性。 Object.defineProperty 需要遍历对象的每个属性并为其设置 getter 和 setter，这在大型对象上可能会有性能问题。 更简洁的代码：\nProxy 的使用通常leads to更简洁、更易于理解的代码。 Object.defineProperty 往往需要更多的样板代码，特别是在处理嵌套对象时。 原始对象不被修改：\nProxy 创建一个原始对象的代理，不直接修改原始对象。 Object.defineProperty 直接修改原始对象。 可撤销代理：\nProxy 提供 Proxy.revocable()，允许创建可撤销的代理。 Object.defineProperty 没有类似的功能。 更好的错误捕获：\nProxy 可以捕获并抛出更多类型的错误，提供更好的调试体验。 支持更多数据类型：\nProxy 可以代理各种类型的对象，包括数组、函数、甚至是 DOM 节点。 Object.defineProperty 主要用于对象的属性。 元编程能力：\nProxy 提供了强大的元编程能力，允许你自定义对象的基本行为。 示例对比：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 使用 Object.defineProperty let obj = { a: 1 }; Object.defineProperty(obj, \u0026#39;a\u0026#39;, { get() { console.log(\u0026#39;Getting a\u0026#39;); return this._a; }, set(newVal) { console.log(\u0026#39;Setting a\u0026#39;); this._a = newVal; } }); // 使用 Proxy let obj = { a: 1 }; let proxy = new Proxy(obj, { get(target, property) { console.log(`Getting ${property}`); return target[property]; }, set(target, property, value) { console.log(`Setting ${property}`); target[property] = value; return true; } }); 在这个例子中，Proxy 版本可以拦截所有属性的访问和设置，而不仅仅是 \u0026lsquo;a\u0026rsquo;。\n总的来说，Proxy 提供了更强大、更灵活的对象操作拦截能力，这也是为什么 Vue 3 选择使用 Proxy 来重写其响应式系统的原因。然而，Proxy 的一个主要缺点是它不支持 IE 浏览器，这在某些需要兼容旧版浏览器的项目中可能是一个问题。\n16. vue 相对于 react 有哪些优势？ 相对于 React，Vue 在方法层面具有以下优势：\n1. 更简洁的模板语法 Vue 使用的是模板语法（Template），它类似于 HTML，可以让开发者直观地绑定数据和事件。Vue 的模板语法对大部分前端开发者来说更加容易上手，因为它使用的是基于现有 HTML 扩展的语法，像指令（v-bind, v-model, v-if）等来实现功能。 React 采用 JSX 语法，虽然功能强大，但对不熟悉 JavaScript 扩展语法的开发者来说，可能不太直观。React 通过在 JavaScript 中混合 HTML 元素来构建视图，开发者需要更多地掌握 JavaScript。 2. 双向数据绑定 Vue 默认支持 双向数据绑定，通过 v-model 可以非常方便地实现表单数据的双向同步，尤其在表单处理和用户输入交互上表现得更为简洁。Vue 的双向绑定通过 getter 和 setter 自动更新 DOM。 React 不提供内置的双向数据绑定，开发者需要手动管理表单控件的状态，处理表单数据同步的逻辑，通常需要写更多的代码。 3. 计算属性（Computed Properties） Vue 提供了计算属性（computed），用于基于已有的状态派生出新的状态，并且自动追踪依赖关系，避免重复计算。计算属性使得代码更加直观简洁，尤其适用于在视图中计算和处理数据。 React 没有提供类似计算属性的功能，开发者需要在 JSX 中直接计算状态或者通过 Hooks 手动实现计算和依赖追踪，这往往增加了代码的复杂性。 4. 内置的指令和指令简化 Vue 提供了丰富的指令，例如 v-show, v-if, v-for, v-bind, v-on 等，使得常见的 DOM 操作和事件绑定变得简单明了。这些指令让开发者无需手动处理 DOM 或事件。 React 没有内置这些指令，开发者需要通过 JavaScript 或 JSX 语法来实现，逻辑上相对复杂。 5. 渐进式框架 Vue 是一个渐进式框架，提供了更灵活的集成方式。开发者可以将 Vue 作为一个库来为现有项目添加交互性，或者将其扩展为一个完整的前端框架，而不会像 React 一样要求从头到尾采用单一的方式。 React 主要作为视图层的库，不提供完整的框架式功能，开发者通常需要引入其他库（如 Redux, React Router）来构建复杂的应用。 6. Vue CLI 对于项目的支持 Vue CLI 提供了开箱即用的项目配置模板，能够快速生成 Vue 项目结构，自动支持 TypeScript、Babel、Linting 等配置。 React 虽然有 Create React App 作为项目初始化工具，但在某些特定项目需求下，Vue CLI 提供了更多的配置灵活性和插件支持。 7. 更好的组件通信（基于 props 和 emit 的模式） Vue 中，父子组件通信通过 props 和 emit 非常直观，遵循单向数据流。同时，Vue 3 提供了 provide/inject 机制，进一步简化了多层嵌套组件之间的通信。 React 主要通过 props 来实现父子组件通信，在更复杂的情况下，可能需要引入上下文 API 或其他状态管理工具。 8. 动画过渡支持 Vue 原生支持动画和过渡效果，通过 transition 和 transition-group 组件，开发者可以轻松为元素添加动画效果。 React 没有内置的动画功能，通常需要引入第三方库如 react-transition-group 或 framer-motion 来实现。 总结： Vue 在模板语法、双向绑定、计算属性、指令支持以及 CLI 工具等方面提供了更直观和简洁的解决方案，特别是在项目规模相对较小时，Vue 的学习曲线更平滑，开发体验更顺畅。而 React 的灵活性和生态系统广度适合构建更大型、复杂的应用，但需要更强的 JavaScript 基础。\n这并不是说 Vue 绝对优于 React，而是两者各有其适用场景，Vue 的方法和设计理念让它在某些开发场景中表现得更加简洁直观。\n18. vue 组件在什么时候会执行组件销毁？是当一个页面跳转到另一个页面时，之前的页面的组件都会被销毁吗？ 这是一个很好的问题，涉及到 Vue 组件的生命周期和路由管理。让我们详细探讨一下：\n组件销毁的时机 Vue 组件在以下情况下会被销毁：\na. 当组件被从 DOM 中移除时。 b. 当使用 v-if 指令且条件变为 false 时。 c. 当使用 v-for 指令且对应的数组项被移除时。 d. 当组件的父组件被销毁时。\n页面跳转时的组件销毁 关于页面跳转时组件是否被销毁，这取决于你的路由配置和应用结构：\na. 单页应用（SPA）中的普通路由切换：\n通常情况下，当从一个页面跳转到另一个页面时，前一个页面的组件会被销毁，新页面的组件会被创建。 这是因为在默认情况下，Vue Router 会在路由变化时卸载旧的组件，并挂载新的组件。 b. 使用 组件：\n如果你使用了 包裹路由组件，则组件在切换时不会被销毁，而是会被缓存。 这种情况下，组件会触发 deactivated 钩子而不是 destroyed 钩子，当再次进入时会触发 activated 钩子。 c. 嵌套路由：\n在嵌套路由的情况下，只有发生变化的部分会被销毁和重新创建，而共享的父级组件会保持不变。 d. 动态组件：\n使用 的动态组件，在切换时默认也会销毁旧组件并创建新组件，除非使用 。 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!-- App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 使用 keep-alive 的情况 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;keep-alive\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/keep-alive\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 验证组件销毁 你可以在组件中添加 destroyed 生命周期钩子来验证组件是否被销毁：\n1 2 3 4 5 export default { destroyed() { console.log(\u0026#39;Component destroyed\u0026#39;); } } 注意事项 组件销毁时，所有的事件监听器和子组件也会被销毁。 如果在组件中设置了定时器或添加了全局事件监听，应该在 beforeDestroy 或 destroyed 钩子中清理它们，以防止内存泄漏。 性能考虑 频繁地销毁和重建组件可能会影响性能。在某些情况下，使用 可以提高性能和用户体验。 但是过度使用 也可能导致内存占用增加，需要权衡。 Vue 3 的变化 在 Vue 3 中，生命周期钩子有些变化：\ndestroyed 改名为 unmounted beforeDestroy 改名为 beforeUnmount 总结： 在默认情况下，当在单页应用中从一个页面跳转到另一个页面时，前一个页面的组件通常会被销毁。但这个行为可以通过 、嵌套路由等方式来改变。了解组件的生命周期和销毁机制对于正确管理资源、优化性能和防止内存泄漏非常重要。\n","date":"2020-09-09T00:00:00Z","permalink":"https://trinyoung.github.io/interview/p/test-chinese/","title":"vue 面试题汇总2"}]