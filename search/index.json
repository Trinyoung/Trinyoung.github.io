[{"content":"1. 说一下react的生命周期，以及对应的钩子函数？ React 的生命周期方法主要分为三个阶段：挂载阶段 (Mounting)、更新阶段 (Updating) 和 卸载阶段 (Unmounting)。这些生命周期方法在类组件中尤为明显，下面详细介绍各个阶段的生命周期和对应的钩子函数：\n1. 挂载阶段 (Mounting) 当组件实例被创建并插入到 DOM 中时，触发以下钩子函数：\nconstructor()\n触发时机：组件被初始化时调用。 作用：用于初始化状态 state 和绑定事件处理方法。 static getDerivedStateFromProps(props, state)\n触发时机：在组件实例化时以及每次更新前被调用。 作用：返回新的状态对象，或返回 null 表示状态不需要更新。 render()\n触发时机：每次组件渲染时调用。 作用：返回组件的 JSX。 componentDidMount()\n触发时机：组件第一次渲染完成后调用。 作用：适合进行异步请求、数据获取或设置订阅等操作。 2. 更新阶段 (Updating) 当组件的 props 或 state 发生变化时，会进入更新阶段，触发以下钩子函数：\nstatic getDerivedStateFromProps(props, state)\n与挂载阶段一致，每次更新前都会被调用。 shouldComponentUpdate(nextProps, nextState)\n触发时机：在组件更新之前调用。 作用：返回 true 或 false 决定组件是否需要重新渲染，默认返回 true。 render()\n在组件更新阶段会再次被调用，用于重新渲染组件。 getSnapshotBeforeUpdate(prevProps, prevState)\n触发时机：更新发生在 DOM 更新之前调用。 作用：捕获一些 DOM 信息，例如滚动位置，可以返回值作为 componentDidUpdate 的第三个参数。 componentDidUpdate(prevProps, prevState, snapshot)\n触发时机：组件更新后调用。 作用：可以进行 DOM 操作或再次发起请求。 3. 卸载阶段 (Unmounting) 当组件从 DOM 中移除时，触发以下钩子函数：\ncomponentWillUnmount() 触发时机：组件即将卸载和销毁时调用。 作用：可以用于清理定时器、取消订阅等。 4. 错误处理 (Error Handling) 当组件渲染或生命周期方法中抛出错误时，触发以下钩子函数：\nstatic getDerivedStateFromError(error)\n触发时机：当子组件抛出错误时调用。 作用：用于更新 state 以显示错误界面。 componentDidCatch(error, info)\n触发时机：当子组件抛出错误时调用。 作用：用于记录错误信息或进行错误处理。 React 16.3 以后新生命周期方法与已废弃方法 React 16.3 开始，推荐使用 getDerivedStateFromProps 和 getSnapshotBeforeUpdate。 旧的生命周期方法如 componentWillMount、componentWillReceiveProps 和 componentWillUpdate 在严格模式下被标记为不安全，并计划在未来版本中删除。 图示帮助理解 一个图示可以更好地帮助你了解 React 生命周期的顺序：\n1 2 3 4 Mounting: constructor → getDerivedStateFromProps → render → componentDidMount Updating: getDerivedStateFromProps → shouldComponentUpdate → render → getSnapshotBeforeUpdate → componentDidUpdate Unmounting: componentWillUnmount Error Handling: getDerivedStateFromError → componentDidCatch 总结 React 生命周期方法让我们在不同阶段对组件进行控制，类组件中常用这些钩子函数来实现数据请求、资源管理和性能优化等操作。\n2. 说一下什么是jsx? JSX (JavaScript XML) 是一种 JavaScript 的语法扩展，通常用于在 React 中描述用户界面。它看起来非常像 HTML，但实际上在浏览器中运行之前会被编译成 JavaScript 函数调用。\n特点与原理 语法类似于 HTML: JSX 允许你在 JavaScript 代码中编写类似 HTML 的标签语法，可以直接描述组件的结构，这让 UI 代码更具可读性和直观性。例如：\n1 const element = \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;; 需要编译: 浏览器无法直接理解 JSX，所以需要通过如 Babel 这样的编译器将其转换为标准的 JavaScript 代码。例如，上述 JSX 代码在编译后会变成：\n1 const element = React.createElement(\u0026#39;h1\u0026#39;, null, \u0026#39;Hello, World!\u0026#39;); 表达式与嵌套: JSX 允许在 {} 中嵌入 JavaScript 表达式。例如：\n1 2 const name = \u0026#34;John\u0026#34;; const element = \u0026lt;h1\u0026gt;Hello, {name}!\u0026lt;/h1\u0026gt;; 属性与子元素: 你可以向 JSX 元素传递属性和嵌套子元素，类似于 HTML。例如：\n1 const element = \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt;\u0026lt;h1\u0026gt;Hello, JSX!\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt;; 优势 直观性: JSX 让 UI 组件的结构与逻辑紧密结合在一起，开发者可以直观地看到组件的渲染结构。 更强的可维护性: 与分离的 HTML、CSS 和 JS 不同，JSX 通过组合组件的方式，提供了更好的模块化能力。 注意事项 JSX 是表达式: JSX 可以赋值给变量、作为函数参数、从函数中返回，灵活性很高。 属性规范: 在 JSX 中，class 应该写为 className，for 应该写为 htmlFor，以符合 JavaScript 的命名规则。 总结: JSX 是一种将 UI 与逻辑相结合的语法糖，它使得 React 组件的开发变得更高效、直观和可维护。在使用 React 开发应用时，JSX 是一种核心的工具。\n3. 对比一下react jsx 和 vue 中的 template 模板语法有何区别？ React JSX 和 Vue 中的模板语法都是用来描述视图结构的，但两者在设计理念、灵活性、语法特性等方面有明显的区别。以下是它们的主要区别：\n1. 语法层面 React JSX:\n更接近 JavaScript，允许在 JSX 中直接编写 JavaScript 表达式，因此具有更强的灵活性和可编程性。 支持 JavaScript 原生控制语句（如 if、for 等），需要借助三元表达式或逻辑运算符来实现条件渲染和列表渲染。 JSX 使用 HTML 标签作为函数调用的语法糖，实际上会被编译成 React.createElement 方法。 1 2 3 4 5 6 const isLoggedIn = true; return ( \u0026lt;div\u0026gt; {isLoggedIn ? \u0026lt;h1\u0026gt;Welcome back!\u0026lt;/h1\u0026gt; : \u0026lt;h1\u0026gt;Please sign in.\u0026lt;/h1\u0026gt;} \u0026lt;/div\u0026gt; ); Vue Template:\n采用类似于 HTML 的模板语法，允许使用特殊的指令（如 v-if、v-for 等）来实现条件渲染和列表渲染，这些指令更贴近 HTML，简单易用。 Vue 的模板不直接包含复杂的 JavaScript 逻辑，而是通过指令和表达式来描述视图，更注重视图的声明式描述。 1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1 v-if=\u0026#34;isLoggedIn\u0026#34;\u0026gt;Welcome back!\u0026lt;/h1\u0026gt; \u0026lt;h1 v-else\u0026gt;Please sign in.\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 2. 灵活性 React JSX:\n可以在 JSX 中编写复杂的逻辑，所有表达式都是 JavaScript 代码，具有更高的灵活性和可定制性。你可以将组件的渲染逻辑与 JavaScript 的条件判断、循环、函数等结合使用。 Vue Template:\n更强调视图与逻辑的分离，模板部分主要用于描述视图结构。虽然模板中也可以编写简单的表达式，但不支持复杂的控制逻辑，较为简洁和易读。 3. 编译原理 React JSX:\nJSX 会被编译成 React.createElement 调用，在运行时生成虚拟 DOM，最终由 React 渲染成真实 DOM。 Vue Template:\nVue 模板会被编译成渲染函数 (render 函数)，然后在运行时生成虚拟 DOM。这使得 Vue 在运行时与 React 类似，但模板语法的编译过程相对复杂。 4. 开发体验 React JSX:\n更自由和灵活，适合复杂逻辑的表达，但代码可能显得较为繁琐，尤其对于没有 JavaScript 背景的开发者来说，理解成本较高。 Vue Template:\n更接近传统 HTML，学习成本低，对于初学者和前端开发者来说更加友好，模板语法简单直观。 5. 状态与数据绑定 React JSX:\n数据绑定是单向的，需要通过 setState 或者 Hooks（如 useState）来更新组件状态。 Vue Template:\n支持双向数据绑定（使用 v-model），使得表单控件的处理更加方便。 总结 React JSX 更适合具有 JavaScript 编程能力的开发者，提供更大的灵活性和更强的逻辑处理能力。 Vue Template 则更专注于视图的声明式描述，更加易读、易学，尤其对于初学者和专注于前端视图开发的工程师更友好。 两者各有优势，选择取决于团队技术背景、项目复杂度以及开发者对视图逻辑的偏好。\n3. 说一下react 类组件和函数组件的区别？ React 类组件和函数组件是 React 中用于定义组件的两种不同方式。它们在语法、性能、特性等方面存在一定的区别，以下是它们的详细对比：\n1. 语法和定义 类组件 (Class Component):\n通过 ES6 类语法定义，继承自 React.Component，并且必须包含一个 render 方法，该方法返回 JSX。 通常使用类的方法来处理生命周期和状态。 1 2 3 4 5 6 7 8 9 10 11 12 class MyComponent extends React.Component { constructor(props) { super(props); this.state = { count: 0, }; } render() { return \u0026lt;div\u0026gt;{this.state.count}\u0026lt;/div\u0026gt;; } } 函数组件 (Function Component):\n使用 JavaScript 函数定义，直接接收 props 作为参数，并返回 JSX。 通过 React Hooks（如 useState 和 useEffect）来处理状态和生命周期。 1 2 3 4 5 function MyComponent() { const [count, setCount] = React.useState(0); return \u0026lt;div\u0026gt;{count}\u0026lt;/div\u0026gt;; } 2. 状态管理和生命周期 类组件:\n具有内置的状态管理能力，通过 this.state 和 this.setState 来管理状态。 提供了完整的生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount 等，可以更细粒度地控制组件的生命周期。 函数组件:\n没有原生的状态管理和生命周期方法，需要使用 React Hooks（如 useState、useEffect 等）来实现相同的功能。 Hooks 可以更方便地组织逻辑，并且可以在一个组件中组合多个 useEffect 实现逻辑的分离。 3. 性能和效率 类组件:\n在 React 16.8 以前，类组件是唯一可以管理状态的方式，但是由于类组件包含更多的逻辑和开销（如 this 绑定），相对来说性能不如函数组件高效。 函数组件:\n函数组件通常更轻量，不需要 this 绑定，性能上更加高效，尤其是搭配 React Hooks 的使用。 React 团队建议在新项目中优先使用函数组件，因为它们更简洁且性能更优。 4. 可读性和代码简洁性 类组件:\n代码相对复杂，容易出现冗余，特别是在状态和事件处理时需要 this 绑定。 对于初学者来说，可能会因为 this 关键字的使用而增加理解难度。 函数组件:\n代码更加简洁，易读易维护，避免了 this 相关的困扰。 更符合函数式编程的风格，可以通过 Hooks 使逻辑更直观地组合和复用。 5. 开发体验 类组件:\n由于类组件具有完整的生命周期方法，可以更明确地进行生命周期阶段的控制，适用于一些复杂的业务场景。 函数组件:\nHooks 的引入使函数组件的功能更加丰富，并且可以实现与类组件相同的状态管理和副作用处理，开发体验上更加现代化。 6. 未来趋势 React 从 16.8 版本开始引入了 Hooks，Hooks 已经成为官方推荐的管理状态和副作用的方式。React 官方表示，未来的新功能和特性会更加侧重于函数组件，因此函数组件被认为是 React 未来的发展方向。 总结 类组件 更适合传统 React 开发方式，适用于需要完整生命周期管理或对老项目进行维护的场景。 函数组件 更简洁、性能更高，结合 Hooks 提供了更强的灵活性和开发体验，是现代 React 开发的首选。 在实际开发中，建议优先使用函数组件，只有在需要兼容老项目或特定场景时才使用类组件。\n4. 为什么react 和 vue 都选择了hook？ Vue 和 React 都选择引入 Hooks 的原因主要有以下几个方面：\n1. 逻辑复用性增强 问题：在 Vue 和 React 的传统组件开发方式中，逻辑复用通常需要通过高阶组件 (HOC) 或混入 (Mixins) 来实现，这种方式会导致代码结构变得复杂，逻辑难以追踪，增加了维护成本。 Hooks 的优势：Hooks 提供了一种更加直观和轻量的方式来实现逻辑复用。开发者可以将组件中的逻辑提取到独立的 Hook 函数中，并在不同组件中直接调用，实现逻辑的共享和复用。例如，React 中的 useState、useEffect，Vue 中的 ref、watchEffect 等都使逻辑分离更加容易。 2. 函数式编程的特性 函数组件和组合式 API：Hooks 引入了函数式编程的特性，使得组件逻辑更加清晰和简洁。React 和 Vue 都在函数组件或组合式 API 中使用 Hooks，将状态和生命周期管理函数化，使代码更易读、易维护。 函数更易组合：通过 Hooks，可以更方便地将逻辑模块化，从而实现代码的组合和复用。例如，在 Vue 3 中使用 setup 函数可以将相关的逻辑组织在一起，使组件内部的代码结构更加清晰。 3. 解决组件复杂度问题 类组件的问题：React 类组件和 Vue 2.x 的选项式 API 在处理复杂状态逻辑时，会导致代码变得难以管理，特别是生命周期方法分散在各个部分，导致逻辑的割裂。而 Hooks 通过函数形式，将相关的逻辑组合到一起，解决了类组件的复杂性问题。 Hooks 带来的优势：通过 React Hooks 和 Vue 3 的组合式 API，状态、生命周期、事件等逻辑可以在一个函数作用域内处理，代码变得更加易读和维护。 4. 性能优化 更轻量的组件：函数组件加上 Hooks 在性能上往往更轻量，因为函数组件不需要实例化类，减少了内存和性能开销。 对渲染的控制：React 中的 Hooks 允许开发者通过 useMemo、useCallback 等手段来优化渲染性能。同样地，Vue 3 也引入了 computed 和 watch 来实现对性能的优化。 5. 未来的趋势和生态 统一 API 和开发体验：通过 Hooks，React 和 Vue 都实现了状态管理、生命周期管理、逻辑复用等功能的一致化，使开发体验更统一和一致，也更容易将项目从类组件过渡到函数组件或组合式 API。 社区和生态的推动：React Hooks 和 Vue 3 的组合式 API 已经得到了社区的广泛支持，越来越多的第三方库也开始兼容和支持 Hooks，推动了它们的普及。 总结 Vue 和 React 都选择 Hooks 是为了：\n提高逻辑复用性，解决原本组件开发中逻辑难以复用的问题。 提供更简洁、清晰、函数式的开发方式，改善代码组织和可维护性。 提供更强大的性能优化手段，适应现代前端开发的需求。 顺应未来的开发趋势，统一 API，推动生态发展。 两者虽然有不同的设计理念，但在 Hooks 这一点上，目标是一致的：通过函数式的方式让开发更高效、灵活、易维护。\n什么是HOC? HOC（Higher-Order Component）是 React 中的一个概念，它指的是一个函数，该函数接受一个组件作为参数，返回一个新的组件。HOC 的主要作用是将一些通用的逻辑提取出来，并将其封装成一个函数，然后通过 HOC 的方式来复用这些逻辑。 高阶组件（HOC）就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种组件的设计模式，这种设计模式是由react自身的组合性质必然产生的。我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。 1）HOC的优缺点 ● 优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。 ● 缺点∶hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖\n2）适用场景 ● 代码复用，逻辑抽象 ● 渲染劫持 ● State 抽象和更改 ● Props 更改\n哪些方法会触发React重新渲染？重新渲染render 会做些什么？ react 的事件机制是如何实现的？ React 的事件机制与传统的 DOM 事件机制有所不同，它实现了一套基于合成事件（Synthetic Event）的系统。合成事件是一种跨浏览器的事件封装，用来统一不同浏览器的事件行为，同时提高性能。下面是 React 事件机制的详细实现过程：\n1. 合成事件（Synthetic Event） React 为了解决浏览器的兼容性问题，创建了一套自己的事件系统，称为“合成事件”。合成事件是对原生事件的封装，确保在不同浏览器下事件行为一致。\n合成事件具有以下特点：\nReact 会拦截所有原生事件，并将它们转换为合成事件。 合成事件对象模仿了原生事件对象，但不直接来自浏览器的事件对象。 合成事件会被自动回收并重用，提升性能。 2. 事件委托 React 的事件处理基于事件委托机制。它并不会为每个 DOM 元素绑定事件处理器，而是在组件的根节点（通常是 document 或 #root）上统一绑定所有事件。\n事件委托的工作原理：\n当用户触发事件时，事件冒泡到根节点，在根节点上统一处理事件。 React 会根据触发事件的目标元素和事件类型，在内部进行事件调度和分发，找到对应的组件和事件处理函数。 这样做的好处：\n减少内存消耗：不需要为每个元素都绑定独立的事件处理器。 简化事件管理：所有事件都集中处理，统一调度。 3. 事件冒泡与捕获 React 的事件系统支持事件冒泡和事件捕获。你可以通过 capture 属性指定是否使用捕获阶段来处理事件：\n1 \u0026lt;button onClick={handleClick} onClickCapture={handleCapture}\u0026gt;Click me\u0026lt;/button\u0026gt; onClick 默认会在冒泡阶段触发。 onClickCapture 则会在捕获阶段触发。 4. 事件池化 React 使用事件池（event pooling）来优化性能。每次触发事件时，React 并不会为每个事件分配一个新的对象，而是复用旧的事件对象。\n合成事件对象在事件处理函数执行完成后会被重置和回收，因此在事件回调函数中异步使用事件对象时，必须先调用 event.persist()，以避免事件对象被重用。\n1 2 3 4 5 6 function handleClick(event) { event.persist(); // 保留事件对象，防止其被复用 setTimeout(() =\u0026gt; { console.log(event.type); // 可以安全使用事件对象 }, 1000); } 5. 阻止默认行为与停止冒泡 与原生 DOM 事件类似，React 的合成事件也提供了 preventDefault() 和 stopPropagation() 方法来阻止默认行为和事件冒泡。\nevent.preventDefault()：阻止浏览器执行事件的默认行为。 event.stopPropagation()：阻止事件冒泡到父级元素。 6. 事件绑定方式 在 React 中，事件处理函数通常通过 JSX 的形式绑定，语法上与原生 HTML 事件不同，React 使用小驼峰命名的事件属性，例如：\n1 \u0026lt;button onClick={handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt; 而不是：\n1 \u0026lt;button onclick=\u0026#34;handleClick()\u0026#34;\u0026gt;Click me\u0026lt;/button\u0026gt; 另外，React 中事件处理函数的 this 指向默认情况下不会自动绑定到组件实例，必须手动绑定或使用箭头函数处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 方法1：手动绑定 class MyComponent extends React.Component { constructor(props) { super(props); this.handleClick = this.handleClick.bind(this); } handleClick() { console.log(this); // 正确绑定到组件实例 } render() { return \u0026lt;button onClick={this.handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt;; } } // 方法2：使用箭头函数自动绑定 class MyComponent extends React.Component { handleClick = () =\u0026gt; { console.log(this); // 自动绑定到组件实例 }; render() { return \u0026lt;button onClick={this.handleClick}\u0026gt;Click me\u0026lt;/button\u0026gt;; } } 7. 性能优化：批量更新 React 的事件处理机制与其状态更新机制结合得非常紧密。React 在事件处理函数中触发状态更新时，通常会进行批量更新，而不是每次调用 setState 都立即触发重新渲染。批量更新减少了不必要的重新渲染，提高了性能。\n总结： React 的事件机制通过合成事件、事件委托和事件池化等技术实现了高效、跨浏览器一致的事件处理系统。开发者只需使用 React 提供的事件接口，专注于业务逻辑，而不必关心底层的事件绑定和优化问题。\n说一下什么是虚拟DOM？它如何工作？ 虚拟 DOM（Virtual DOM）是 React 用于优化 UI 渲染性能的一种技术，它是对真实 DOM 的一种抽象表示，可以理解为在内存中以 JavaScript 对象形式存在的 DOM 树的副本。通过虚拟 DOM，React 可以高效地管理 UI 的更新，减少真实 DOM 操作的次数，从而提升性能。\n1. 什么是虚拟 DOM？ 虚拟 DOM 是一个轻量级的 JavaScript 对象，它表示了 DOM 树的结构，包含了真实 DOM 元素的属性、节点关系以及内容等信息。虚拟 DOM 并不直接映射到浏览器，而是存在于内存中，当状态或数据发生变化时，React 首先在虚拟 DOM 上进行计算，然后将差异更新到真实 DOM 中。\n2. 虚拟 DOM 工作流程 当组件的状态或属性发生变化时，虚拟 DOM 的更新和渲染过程一般分为以下几个步骤：\nStep 1: 构建虚拟 DOM 当应用初次渲染时，React 会根据组件的 render() 方法生成一棵虚拟 DOM 树。 这个虚拟 DOM 是由纯 JavaScript 对象组成的，描述了页面的初始状态。 Step 2: 状态更新，生成新的虚拟 DOM 当组件的 state 或 props 发生变化时，React 会重新调用 render() 方法，生成一棵新的虚拟 DOM 树。 Step 3: Diff 算法比较新旧虚拟 DOM React 会使用 “Diff 算法” 比较新的虚拟 DOM 与旧的虚拟 DOM，找出两者之间的差异（即需要更新的部分）。 Diff 算法的复杂度被优化到 O(n)，意味着它只会检查有变化的节点，忽略没有变化的部分。 Step 4: 计算差异（Reconciliation） React 将新旧虚拟 DOM 的差异（称为“补丁”或“patch”）记录下来，这些差异包含了应该如何更新真实 DOM。 Step 5: 更新真实 DOM 最后，React 会将这些差异应用到真实 DOM 中，进行必要的更新操作。由于 React 只会更新发生变化的部分，这极大地提高了渲染效率。 3. 虚拟 DOM 的优势 性能优化：与直接操作真实 DOM 相比，虚拟 DOM 通过在内存中进行计算，大幅减少了对真实 DOM 的操作次数，从而提高了性能。 跨平台能力：虚拟 DOM 是与平台无关的 JavaScript 对象，可以被用来生成多种目标输出，不仅限于浏览器的 DOM 操作。这使得 React 可以用于构建移动应用（如 React Native）。 简化开发：开发者只需关注组件的状态变化，而无需手动操作 DOM，React 会自动进行更新和渲染，提供更简洁的开发体验。 4. Diff 算法的工作原理 React 在更新虚拟 DOM 时，使用了一种高效的 Diff 算法来比较新旧虚拟 DOM 树，主要基于以下三条策略：\n同级比较：只会对同一级别的节点进行比较，不会跨级比较，这样大大降低了计算复杂度。 节点类型不同，直接替换：如果两个节点的类型不同（例如从 \u0026lt;div\u0026gt; 变为 \u0026lt;span\u0026gt;），则会直接移除旧节点及其子节点，并创建新的节点。 通过 key 进行列表比较：当渲染列表时，React 通过每个节点的 key 值来识别节点的身份，从而准确、高效地处理节点的增删改操作。 5. 虚拟 DOM 的局限性 初次渲染性能：虚拟 DOM 在初次渲染时会生成整个虚拟 DOM 树，对于大型应用来说，初次渲染的性能可能会受到影响。 不适用于所有场景：在高性能要求的场景（如 WebGL、游戏开发）中，手动优化可能比虚拟 DOM 更有效。 总结 虚拟 DOM 是 React 提高渲染性能的核心技术，通过在内存中维护一个虚拟的 DOM 树，将每次状态变化引起的 DOM 更新变得更高效。它通过 Diff 算法计算新旧虚拟 DOM 之间的差异，并将最小的更新应用到真实 DOM，从而实现性能的优化和快速的界面更新。\n对react fiber的理解，它解决了什么问题？ React Fiber 是 React 16 版本引入的新架构，它是一种用于协调和渲染 React 应用的渐进式调度算法，旨在提高 React 应用的性能，特别是对于大型应用和复杂的动画效果。\n1. 为什么需要 Fiber React 在早期的版本中，使用的是同步递归渲染机制，这意味着在一次更新中，React 会从根节点开始递归地进行渲染工作，直到整个组件树渲染完成。在大型组件树或复杂的渲染过程中，这可能会导致浏览器阻塞，导致页面卡顿或无法响应用户的交互。\n为了提升性能和提高渲染的流畅度，React Fiber 引入了一种新的架构，能够将渲染工作拆分成更小的任务单元，并允许在任务之间进行调度，从而更好地控制渲染的优先级，避免阻塞主线程。\n2. React Fiber 的核心概念 Fiber 是一种数据结构：它将每个组件的更新任务以链表的形式存储，形成一个Fiber 树，使得 React 可以逐步地、增量地更新视图。 可中断的渲染：Fiber 的最大优势是能够将渲染过程切分成小块，并且在必要的时候暂停、恢复或终止渲染任务，以确保高优先级的任务（如用户交互）能及时响应。 优先级调度：Fiber 会根据不同任务的优先级分配时间片（time slices）。这样高优先级的任务（如动画、输入事件）会比低优先级的任务（如数据加载）更早地得到处理。 3. React Fiber 的工作阶段 React Fiber 分为两个主要的阶段：\n调度阶段（Reconciliation Phase）：这一阶段是计算哪些组件需要更新的过程。Fiber 会遍历整个 Fiber 树，构建一个新版本的 Fiber 树，并确定要进行的更改。在这一步中，Fiber 可以暂停或中断，等待空闲时间继续执行。\n提交阶段（Commit Phase）：这一阶段是将更新应用到实际的 DOM 中。在这个阶段，操作是真正同步执行的，并且无法被打断。\n4. Fiber 和传统 Stack Reconciler 的区别 可中断性：传统的 Stack Reconciler 是同步的、递归的，不能中断，而 Fiber 是异步的、可中断的。 优先级控制：Fiber 能根据任务的重要性对任务进行调度，而传统架构无法做到这一点。 5. Fiber 的应用场景 动画和流畅的用户交互：Fiber 能够让 React 应用在复杂的动画、过渡效果下保持流畅。 大型组件树：对于渲染庞大组件树的应用，Fiber 能有效减少卡顿，确保高优先级的任务可以及时得到响应。 6. Fiber 的限制 虽然 React Fiber 引入了很多优点，但它也有一定的复杂性，例如调度算法的复杂性更高，同时它也会引入一定的性能开销，因此它并不是万能的优化工具，而是解决特定场景下性能问题的一种方案。\n总结 React Fiber 提供了一种更灵活、更高效的渲染方式，通过引入渐进式的调度机制，实现了对渲染任务的可中断和优先级调度，从而在提高性能和流畅度方面提供了巨大优势。\nReact Component 和 PureComponent 的区别？ 默认行为：\nComponent 是 React 中的基本组件类，它不保证任何性能优化措施。 PureComponent 是对 Component 的一个优化版本，它实现了 shouldComponentUpdate 生命周期方法，提供了浅比较（shallow comparison）的优化。 性能优化：\n使用 Component 时，开发者需要手动实现 shouldComponentUpdate 方法来控制组件是否需要更新。 PureComponent 自动实现了一个简单的 shouldComponentUpdate 实现，它会比较新旧 props 和 state，如果它们的引用不同或者值不同，则认为需要更新组件。这种浅比较可以避免不必要的渲染，提高性能。 适用场景：\n如果组件的 props 或 state 变化频繁且复杂，不适合使用 PureComponent，因为它的浅比较机制可能无法准确判断是否需要更新。 对于简单且输入输出关系明确的组件，使用 PureComponent 可以减少开发者的负担，并且提升应用性能。 自定义比较逻辑：\n在 Component 中可以通过自定义 shouldComponentUpdate 来实现更复杂的比较逻辑或条件判断。 PureComponent 不支持自定义 shouldComponentUpdate 的逻辑，如果需要更复杂的逻辑，仍然需要使用普通的 Component 并手动实现该方法。 总结来说，PureComponent 是一种轻量级的性能优化手段，适用于大多数情况下不需要复杂比较逻辑的组件。而 Component 提供了更大的灵活性，可以根据具体需求进行更细致的性能调优\n谈一谈对 React Context 的理解 React Context 是 React 提供的一种用于在组件树中共享数据的机制，允许我们在不通过 props 逐层传递的情况下，轻松地在组件之间共享状态。以下是对 React Context 的详细理解：\n1. 主要用途 全局状态管理：Context 适合用于共享全局状态，如用户认证信息、主题设置、语言选择等。 避免 props drilling：在深层嵌套的组件中，使用 Context 可以避免通过每一层组件传递 props。 2. 创建 Context 使用 React.createContext() 创建一个 Context 对象：\n1 const MyContext = React.createContext(); 3. Provider 和 Consumer Provider：用于提供 Context 的值，包裹需要访问该值的组件。 1 2 3 \u0026lt;MyContext.Provider value={/* 共享的值 */}\u0026gt; {/* 子组件 */} \u0026lt;/MyContext.Provider\u0026gt; Consumer：用于访问 Context 的值，通常在子组件中使用。 1 2 3 \u0026lt;MyContext.Consumer\u0026gt; {value =\u0026gt; /* 使用 Context 的值 */} \u0026lt;/MyContext.Consumer\u0026gt; 4. 使用 useContext Hook 在函数组件中，可以使用 useContext Hook 更简洁地访问 Context 的值：\n1 2 3 import { useContext } from \u0026#39;react\u0026#39;; const value = useContext(MyContext); 5. 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const ThemeContext = React.createContext(\u0026#39;light\u0026#39;); function App() { return ( \u0026lt;ThemeContext.Provider value=\u0026#34;dark\u0026#34;\u0026gt; \u0026lt;Toolbar /\u0026gt; \u0026lt;/ThemeContext.Provider\u0026gt; ); } function Toolbar() { return ( \u0026lt;div\u0026gt; \u0026lt;ThemedButton /\u0026gt; \u0026lt;/div\u0026gt; ); } function ThemedButton() { const theme = useContext(ThemeContext); return \u0026lt;button className={theme}\u0026gt;I am styled by theme context!\u0026lt;/button\u0026gt;; } 6. 性能考虑 重渲染：当 Provider 的值发生变化时，所有使用该 Context 的组件都会重新渲染。因此，应该谨慎选择 Context 的值，避免不必要的重渲染。 分割 Context：如果有多个状态需要共享，可以考虑将它们分割成多个 Context，以减少重渲染的范围。 7. 适用场景 主题切换：在应用中实现主题切换功能。 用户认证：在应用中共享用户的登录状态和信息。 多语言支持：在应用中实现国际化，动态切换语言。 8. 限制 不适合频繁变化的状态：对于频繁变化的状态（如表单输入），使用 Context 可能导致性能问题，建议使用局部状态管理。 复杂性：在大型应用中，过度使用 Context 可能导致代码复杂性增加，难以维护。 9. 结合其他状态管理工具 Context 可以与其他状态管理工具（如 Redux、MobX）结合使用，作为全局状态的补充。 在小型应用中，Context 可以替代 Redux 等复杂的状态管理库。 10. 总结 React Context 是一个强大的工具，适合用于在组件树中共享状态，避免 props drilling。它提供了一种简单的方式来管理全局状态，但在使用时需要注意性能和复杂性。合理地使用 Context 可以提高代码的可读性和可维护性。\nreact 中什么是受控组件，什么是非受控组件？ 在 React 中，受控组件和非受控组件是两种处理表单输入的方式。它们的主要区别在于如何管理组件的状态。\n1. 受控组件（Controlled Components） 定义： 受控组件是指其值由 React 组件的状态（state）控制的组件。所有的输入值都通过 React 的状态管理来处理。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import React, { useState } from \u0026#39;react\u0026#39;; const ControlledComponent = () =\u0026gt; { const [value, setValue] = useState(\u0026#39;\u0026#39;); const handleChange = (event) =\u0026gt; { setValue(event.target.value); }; return ( \u0026lt;input type=\u0026#34;text\u0026#34; value={value} onChange={handleChange} /\u0026gt; ); }; 优点：\n单一数据源：所有的输入值都存储在组件的状态中，便于管理和调试。 实时验证：可以在输入时进行验证和格式化。 更好的控制：可以轻松地实现复杂的交互逻辑，如动态禁用按钮、条件渲染等。 缺点：\n性能开销：每次输入都会触发状态更新，可能导致性能问题，尤其是在大型表单中。 代码复杂性：需要编写额外的代码来管理状态和处理输入。 使用场景：\n需要实时验证和格式化输入的场景。 需要根据输入动态更新其他组件或状态的场景。 需要在表单提交时获取所有输入值的场景。 2. 非受控组件（Uncontrolled Components） 定义： 非受控组件是指其值不由 React 组件的状态控制，而是直接通过 DOM 元素的引用（ref）来访问。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import React, { useRef } from \u0026#39;react\u0026#39;; const UncontrolledComponent = () =\u0026gt; { const inputRef = useRef(null); const handleSubmit = (event) =\u0026gt; { event.preventDefault(); alert(\u0026#39;A name was submitted: \u0026#39; + inputRef.current.value); }; return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={inputRef} /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); }; 优点：\n简单性：不需要管理状态，代码更简洁。 性能：在某些情况下，性能更好，因为不需要频繁更新状态。 缺点：\n难以控制：不容易实现实时验证和格式化。 数据获取：在提交表单时需要通过 ref 获取数据，可能不够直观。 不易调试：由于数据不在 React 的状态中，调试和跟踪数据变化可能更困难。 使用场景：\n简单的表单，且不需要实时验证的场景。 需要快速实现的原型或小型应用。 处理第三方库或非 React 组件的场景。 总结 受控组件：适合需要精确控制和实时反馈的场景，提供更好的可维护性和可调试性。 非受控组件：适合简单场景，减少了状态管理的复杂性，但在复杂交互中可能不够灵活。 选择使用受控组件还是非受控组件，取决于具体的应用需求和复杂性。在大多数情况下，受控组件是推荐的做法，因为它们提供了更好的控制和可维护性。\nreact 中refs 中有哪些应用场景 在 React 中，refs（引用）是一个用于访问和操作 DOM 元素或 React 组件实例的工具。以下是一些常见的 refs 应用场景：\n1. 访问 DOM 元素 直接操作 DOM：当需要直接访问和操作 DOM 元素时，可以使用 refs。例如，聚焦输入框、滚动到特定位置等。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import React, { useRef } from \u0026#39;react\u0026#39;; const FocusInput = () =\u0026gt; { const inputRef = useRef(null); const handleFocus = () =\u0026gt; { inputRef.current.focus(); // 聚焦输入框 }; return ( \u0026lt;div\u0026gt; \u0026lt;input ref={inputRef} type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;button onClick={handleFocus}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; 2. 管理动画 控制动画：在需要控制动画的场景中，可以使用 refs 来访问 DOM 元素并应用动画效果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import React, { useRef } from \u0026#39;react\u0026#39;; const AnimatedBox = () =\u0026gt; { const boxRef = useRef(null); const handleAnimate = () =\u0026gt; { boxRef.current.style.transform = \u0026#39;translateX(100px)\u0026#39;; // 移动盒子 }; return ( \u0026lt;div\u0026gt; \u0026lt;div ref={boxRef} style={{ width: \u0026#39;100px\u0026#39;, height: \u0026#39;100px\u0026#39;, background: \u0026#39;blue\u0026#39; }} /\u0026gt; \u0026lt;button onClick={handleAnimate}\u0026gt;Animate Box\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; 3. 集成第三方库 与非 React 组件集成：在使用第三方库（如 jQuery、D3.js 等）时，可能需要直接访问 DOM 元素。 1 2 3 4 5 6 7 8 9 10 11 12 import React, { useRef, useEffect } from \u0026#39;react\u0026#39;; import $ from \u0026#39;jquery\u0026#39;; const JqueryComponent = () =\u0026gt; { const divRef = useRef(null); useEffect(() =\u0026gt; { $(divRef.current).fadeIn(); // 使用 jQuery 操作 DOM }, []); return \u0026lt;div ref={divRef} style={{ display: \u0026#39;none\u0026#39; }}\u0026gt;Hello, jQuery!\u0026lt;/div\u0026gt;; }; 4. 表单管理 非受控组件：在某些情况下，使用 refs 可以简化表单管理，尤其是在处理第三方库或需要快速实现的场景。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import React, { useRef } from \u0026#39;react\u0026#39;; const UncontrolledForm = () =\u0026gt; { const inputRef = useRef(null); const handleSubmit = (event) =\u0026gt; { event.preventDefault(); alert(\u0026#39;Input value: \u0026#39; + inputRef.current.value); // 直接访问输入值 }; return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input ref={inputRef} type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); }; 5. 访问子组件实例 获取子组件方法：在类组件中，可以使用 refs 访问子组件实例，从而调用其方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Child extends React.Component { sayHello() { alert(\u0026#39;Hello from Child!\u0026#39;); } render() { return \u0026lt;div\u0026gt;Child Component\u0026lt;/div\u0026gt;; } } class Parent extends React.Component { childRef = React.createRef(); handleClick = () =\u0026gt; { this.childRef.current.sayHello(); // 调用子组件方法 }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;Child ref={this.childRef} /\u0026gt; \u0026lt;button onClick={this.handleClick}\u0026gt;Call Child Method\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } 6. 处理焦点管理 焦点控制：在复杂的表单中，可以使用 refs 来管理焦点，确保用户体验流畅。 7. 访问组件的 DOM 节点 获取组件的 DOM 节点：在需要直接操作组件的 DOM 节点时，可以使用 refs。 8. 处理滚动位置 滚动管理：在需要控制滚动位置的场景中，可以使用 refs 来访问和操作滚动条。 总结 refs 在 React 中是一个强大的工具，适用于需要直接访问和操作 DOM 元素或组件实例的场景。尽管 refs 提供了灵活性，但应谨慎使用，避免过度依赖。通常情况下，推荐使用 React 的状态管理和生命周期方法来处理大多数场景，refs 应该用于特定的需求。\nrefs 和 useState 是 React 中用于管理状态和引用的两种不同机制。它们各自有不同的用途和特性。以下是它们之间的主要区别：\n1. 用途 useState：\n用于在函数组件中管理状态。 当状态更新时，组件会重新渲染。 适用于需要响应用户输入、异步请求或其他事件的场景。 refs：\n用于访问和操作 DOM 元素或 React 组件实例。 不会引起组件重新渲染。 适用于需要直接操作 DOM、集成第三方库或管理焦点等场景。 2. 更新机制 useState： 使用 setState 函数更新状态。 更新状态后，React 会重新渲染组件，反映最新的状态。 1 2 const [count, setCount] = useState(0); setCount(count + 1); // 触发重新渲染 refs： 直接通过 ref 对象访问 DOM 元素或组件实例。 更新 refs 的值不会触发组件重新渲染。 1 2 const inputRef = useRef(null); inputRef.current.value = \u0026#39;New Value\u0026#39;; // 不会触发重新渲染 3. 数据持久性 useState：\n状态在组件的生命周期内持久化，组件重新渲染时状态保持不变。 状态可以是基本类型、对象或数组。 refs：\nrefs 的值在组件的生命周期内持久化，但不参与 React 的渲染过程。 适合存储不需要引起渲染的值，如 DOM 引用或计时器 ID。 4. 适用场景 useState：\n适用于需要响应用户交互、表单输入、异步数据请求等场景。 适合管理需要在 UI 中反映的状态。 refs：\n适用于需要直接操作 DOM 元素、集成第三方库、管理焦点等场景。 适合存储不需要在 UI 中反映的值。 5. 性能 useState：\n由于会引起重新渲染，频繁更新状态可能会影响性能。 refs：\n由于不引起重新渲染，使用 refs 可以避免不必要的性能开销。 总结 useState 是用于管理组件状态的钩子，适合需要响应用户交互的场景。 refs 是用于访问和操作 DOM 元素或组件实例的工具，适合需要直接操作 DOM 的场景。 在实际开发中，选择使用 useState 还是 refs 取决于具体的需求和场景。通常情况下，优先使用 useState 来管理需要在 UI 中反映的状态，而在需要直接操作 DOM 或不需要引起渲染的情况下使用 refs。\n类组件和函数组件有何异同？ React 类组件和函数组件有以下异同，且代表了不同的思想：\n一、类组件与函数组件的异同 1. 定义方式 类组件：使用 ES6 的 class 关键字定义，继承自 React.Component，需要实现 render() 方法来返回 JSX。 1 2 3 4 5 class MyComponent extends React.Component { render() { return \u0026lt;div\u0026gt;Hello, Class Component\u0026lt;/div\u0026gt;; } } 函数组件：使用 JavaScript 函数定义，直接返回 JSX。 1 2 3 function MyComponent() { return \u0026lt;div\u0026gt;Hello, Function Component\u0026lt;/div\u0026gt;; } 2. 状态管理 类组件：通过 this.state 管理组件状态，使用 this.setState() 更新状态。 函数组件：原先函数组件是无状态的，但自从 React 16.8 引入 Hooks 后，可以使用 useState 等 Hook 来管理状态。 3. 生命周期 类组件：提供了丰富的生命周期方法（如 componentDidMount、componentDidUpdate、componentWillUnmount 等）来处理组件的不同阶段。 函数组件：没有直接的生命周期方法，但可以使用 useEffect Hook 模拟生命周期行为。 4. this 关键字 类组件：需要注意 this 的绑定问题，必须在构造函数中手动绑定，或者使用箭头函数解决。 函数组件：不存在 this 问题，代码更加简洁。 5. 性能 类组件：由于需要实例化，性能上会略低于函数组件。 函数组件：因为没有实例化过程，性能更优，尤其在引入 Hooks 后，可以满足大部分需求。 二、代表的思想 1. 类组件：面向对象编程 (OOP) 类组件符合面向对象编程的思想，通过 class 定义组件，可以封装状态、方法和生命周期，并支持继承。 组件状态和行为都被封装在对象实例中，组件自身具有更强的独立性。 2. 函数组件：函数式编程 (FP) 函数组件代表了函数式编程的思想，将组件视为纯函数，接收 props 作为输入，返回 UI 作为输出。 Hooks 的引入加强了函数式编程风格，使得状态和副作用也可以通过 Hook 函数实现。 函数组件更加简洁、直观，代码结构更清晰，避免了 this 的困扰，符合 React “UI 即函数”的理念。 总结 类组件和函数组件在实现方式、状态管理、生命周期和性能等方面有明显区别。 类组件代表面向对象编程思想，强调封装和继承；而函数组件代表函数式编程思想，提倡函数的纯粹性和数据不可变性。 在 Hooks 引入后，函数组件变得更加强大和灵活，React 官方也推荐优先使用函数组件进行开发。 React setState的调用原理 是的，您描述的场景基本上是正确的。在 React 中，setState 的调用是异步的，多个状态更新会被合并到一个更新队列中，直到 React 处理这些更新并进行重新渲染。以下是这个过程的详细说明：\n1. 状态更新的异步性 当您调用 setState 方法时，React 不会立即更新组件的状态和重新渲染组件。相反，它会将状态更新请求放入一个更新队列中。这种设计的目的是为了提高性能，避免不必要的渲染。\n2. 更新队列的合并 如果在同一个事件处理函数中多次调用 setState，React 会将这些状态更新合并为一个更新。这意味着，如果您在一个方法中调用了多次 setState，React 会将这些更新合并为一个状态更新操作。\n1 2 3 4 5 increment = () =\u0026gt; { this.setState({ count: this.state.count + 1 }); // 第一次更新 this.setState({ count: this.state.count + 2 }); // 第二次更新 this.setState({ count: this.state.count + 3 }); // 第三次更新 }; 在上面的例子中，虽然调用了三次 setState，但 React 会将这些更新合并为一次更新，最终只会触发一次重新渲染。\n3. 处理更新队列 React 会在合适的时机（例如事件处理完成后、定时器触发后等）处理更新队列。处理更新队列的过程如下：\n合并状态更新：React 会合并所有在同一事件循环中的 setState 调用。 计算新的状态：React 会根据合并后的状态计算出新的状态。 触发重新渲染：一旦更新队列处理完成，React 会重新渲染组件，更新虚拟 DOM，并最终更新真实 DOM。 4. 例子 以下是一个完整的例子，展示了如何在一个事件处理函数中合并多个状态更新：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Counter extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } increment = () =\u0026gt; { this.setState({ count: this.state.count + 1 }); // 更新 1 this.setState({ count: this.state.count + 2 }); // 更新 2 this.setState({ count: this.state.count + 3 }); // 更新 3 // 这里的 count 最终会是 3，而不是 6 }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {this.state.count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={this.increment}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } 5. 使用函数式更新 为了确保每次更新都基于最新的状态，您可以使用函数式更新：\n1 2 3 4 5 6 increment = () =\u0026gt; { this.setState((prevState) =\u0026gt; ({ count: prevState.count + 1 })); this.setState((prevState) =\u0026gt; ({ count: prevState.count + 2 })); this.setState((prevState) =\u0026gt; ({ count: prevState.count + 3 })); // 这里的 count 最终会是 6 }; 总结 React 的 setState 是异步的，多个状态更新会被合并到一个更新队列中。 处理更新队列时，React 会合并状态更新并触发一次重新渲染。 使用函数式更新可以确保每次更新都基于最新的状态。 这种机制使得 React 在处理状态更新时更加高效，避免了不必要的渲染和性能开销。\n完整的说一下当路由进入到当前的react页面时，整个流程是什么？ ","date":"2020-10-09T00:00:00Z","permalink":"https://trinyoung.github.io/interview/p/test-chinese2/","title":"React 面试题汇总"},{"content":"React hooks 的理解，它的实现原理是什么？ React Hooks 是 React 16.8 版本引入的一组新的 API，它允许在函数组件中使用 React 的状态和生命周期功能，从而大大增强了函数组件的能力。\n1. Hooks 的基本理解 在没有 Hooks 之前，状态管理、生命周期方法、逻辑复用等特性是通过类组件实现的，这样会导致代码难以复用和管理。React Hooks 提供了一种新的编程范式，使得你可以在函数组件中：\n管理状态（使用 useState） 访问生命周期（使用 useEffect） 使用上下文（使用 useContext） 复用逻辑（自定义 Hook） 2. Hooks 的实现原理 React Hooks 的核心在于闭包和React 的 Fiber 数据结构，通过对每个组件调用 useState、useEffect 等 Hook 函数时，对应地将状态、效果等存储在内存中的 Fiber 节点上，实现函数组件的状态管理和逻辑复用。\n2.1 Hooks 的执行顺序 每次 React 组件渲染时，函数组件会被执行，React 内部会维护一个“Hook 链表”来跟踪每个 Hook 的状态。当你多次调用 useState 或 useEffect 时，React 通过链表来跟踪每个 Hook 的位置和数据。\n2.2 useState 的工作原理 useState 内部维护了一个状态值和一个更新函数。初次渲染时，它将初始状态存储在 Fiber 节点上。 当你调用状态更新函数时，React 会将新的状态值存储到 Fiber 中，并触发组件重新渲染。新的渲染过程会根据 Hook 调用顺序更新 Hook 链表中的状态。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // useState 的简化实现 let currentHookIndex = 0; const hooks = []; function useState(initialValue) { const hookIndex = currentHookIndex; // 初始化时，将初始值存储到 hooks 数组 if (hooks[hookIndex] === undefined) { hooks[hookIndex] = initialValue; } // 更新函数，更新 hook 状态并重新渲染 const setState = (newValue) =\u0026gt; { hooks[hookIndex] = newValue; render(); // 假设这里是重新渲染函数 }; currentHookIndex++; return [hooks[hookIndex], setState]; } 2.3 useEffect 的工作原理 useEffect 在每次渲染完成后都会执行，并且会存储每个 Effect 的依赖数组。 在每次渲染时，React 会对比依赖数组是否发生变化，从而决定是否重新运行 useEffect 中的回调。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // useEffect 的简化实现 function useEffect(callback, dependencies) { const hookIndex = currentHookIndex; // 取出上一次的依赖 const hasChanged = dependencies ? !dependencies.every((item, index) =\u0026gt; item === (hooks[hookIndex]?.[index])) : true; if (hasChanged) { callback(); // 运行 callback hooks[hookIndex] = dependencies; } currentHookIndex++; } 3. React Hooks 优点 函数组件化：无需使用类组件，即可轻松地管理状态、使用副作用。 逻辑复用：通过自定义 Hook，方便地将逻辑抽取成独立的函数，提高代码的复用性。 简化代码：相比类组件，代码更简洁、更直观，减少了不必要的模板和嵌套。 4. 注意事项 Hook 调用顺序：Hooks 必须在组件顶层调用，不能放在条件语句或循环中，否则会破坏其内部状态的记录机制。 依赖数组：使用 useEffect 时，需要正确管理依赖数组，防止多余的副作用执行或遗漏。 总结 React Hooks 通过利用闭包和 Fiber 架构，使得函数组件能够拥有类似类组件的状态管理和生命周期管理能力，并且通过链表结构跟踪每个 Hook 的状态，从而实现了高效的状态更新和逻辑复用。\n为什么useState 要返回一个数组？ 如果 useState 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净 如果 useState 返回的是对象，在解构对象的时候必须要和 useState 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值 react hook的使用限制有哪些？为什么？ React Hooks 的限制主要是为了保证其运行的稳定性和一致性，这些限制包括：\n只能在函数组件的最顶层使用：Hooks 不能在条件语句、循环、嵌套函数中调用。这是为了保证 Hooks 的调用顺序在每次渲染中都保持一致。React 通过这个限制确保在每次渲染时，Hooks 都能正确地找到对应的 state 和 effect。如果在条件语句或循环中使用，会导致调用顺序的变化，进而导致状态混乱或丢失。\n只能在 React 函数中使用 Hooks：Hooks 不能在普通的 JavaScript 函数中使用，只能在 React 函数组件或自定义 Hook 中使用。这是为了确保 Hooks 的逻辑与 React 渲染流程保持一致，从而让 React 能正确管理组件的状态和副作用。\n自定义 Hook 的命名规范：自定义 Hook 必须以 use 开头，这样做是为了帮助 React 自动区分普通函数和自定义 Hook，便于更好地进行调试和优化。\n这些限制主要是为了维护 React Hooks 的工作机制，使得它们能够高效地追踪状态变化，确保数据的准确性和完整性。同时，这些限制也可以帮助开发者遵循最佳实践，避免代码在渲染过程中出现无法预测的问题。\nuseEffect 和 userLayoutEffect 的区别？ useEffect 和 useLayoutEffect 是 React 中两个用于处理副作用的 Hook，它们的主要区别在于执行时机：\n1. 执行时机 useEffect：在浏览器完成渲染后才会执行。它是一个异步的副作用处理方式，这意味着它不会阻塞浏览器的绘制过程。因此，useEffect 更适合那些不需要在页面渲染之前执行的副作用，例如数据请求、订阅、事件监听等。 useLayoutEffect：在浏览器完成 DOM 变更后、浏览器实际绘制页面之前同步执行。这意味着它会在浏览器绘制之前执行完毕，所以会阻塞渲染。useLayoutEffect 更适合那些需要在 DOM 更新后立即读取或修改 DOM 的情况，例如测量 DOM 大小、获取布局信息、修改样式等。 2. 使用场景 useEffect：适合大多数副作用场景，如获取数据、监听事件、订阅等，因为它不会阻塞浏览器的绘制过程，性能更好。 useLayoutEffect：适用于需要在 DOM 更新后立即执行的操作，例如计算布局、测量 DOM 元素尺寸等，因为它能保证在浏览器绘制前执行完。 3. 性能方面 useEffect 是非阻塞的，性能更好，通常更推荐使用。 useLayoutEffect 是阻塞的，如果大量使用，可能会影响性能。 总结 通常情况下，应该优先使用 useEffect，只有在需要同步执行、并且对布局或 DOM 操作要求严格的场景下，才使用 useLayoutEffect。\nReact hooks 和生命周期的关系？ React Hooks 与类组件生命周期之间存在对应关系，Hooks 提供了一种更灵活、更简洁的方式来处理组件生命周期的逻辑。以下是两者的对应关系：\n1. 初始化阶段 (Mounting) 类组件： constructor() componentDidMount() Hooks： useEffect(() =\u0026gt; { ... }, []) useState() / useReducer() 用于初始化状态 useEffect 带空依赖数组 [] 只在组件挂载时执行，与 componentDidMount 的作用相同。初始化状态则可以通过 useState 或 useReducer 完成。\n2. 更新阶段 (Updating) 类组件： componentDidUpdate(prevProps, prevState) Hooks： useEffect(() =\u0026gt; { ... }, [dependencies]) 在 useEffect 中指定依赖项数组 [dependencies]，当这些依赖项发生变化时，useEffect 就会执行，与 componentDidUpdate 类似。\n3. 卸载阶段 (Unmounting) 类组件： componentWillUnmount() Hooks： useEffect(() =\u0026gt; { return () =\u0026gt; { ... } }, []) 在 useEffect 中返回一个清理函数，且指定空依赖数组 []，与 componentWillUnmount 对应，用于清理副作用，例如取消订阅、清除计时器等。\n4. 额外的生命周期方法 类组件： shouldComponentUpdate(nextProps, nextState): 控制组件是否需要更新 getDerivedStateFromProps(props, state): 根据新的 props 更新状态 getSnapshotBeforeUpdate(prevProps, prevState): 读取更新前的 DOM 状态 Hooks： React.memo：类似于 shouldComponentUpdate，用于性能优化 useEffect 或 useLayoutEffect：可以在特定场景下模拟 getSnapshotBeforeUpdate 的效果 对于 getDerivedStateFromProps，一般可以通过 useEffect 或 useState 来实现类似的逻辑。 总结 Hooks 提供了 useEffect 来覆盖 componentDidMount、componentDidUpdate、componentWillUnmount，使得开发者可以在一个地方处理副作用。 Hooks 让函数组件能够管理状态和副作用，简化了原来类组件的生命周期逻辑，减少了代码的复杂性。 useEffect 和 useLayoutEffect 的区别？ useEffect 和 useLayoutEffect 是 React 中用于处理副作用的两个 Hook，它们的主要区别在于执行时机和使用场景。以下是它们的详细比较：\n1. 执行时机 useEffect： 在浏览器完成绘制后执行。也就是说，useEffect 的回调函数会在 DOM 更新后、浏览器绘制完成后执行。 适合处理不需要阻塞浏览器绘制的副作用，如数据获取、订阅、事件监听等。 1 2 3 4 useEffect(() =\u0026gt; { // 这里的代码在 DOM 更新后执行 console.log(\u0026#39;Effect executed after render\u0026#39;); }, [dependencies]); useLayoutEffect： 在浏览器绘制之前执行。useLayoutEffect 的回调函数会在 DOM 更新后、浏览器绘制之前执行。 适合处理需要在浏览器绘制之前完成的副作用，如读取布局信息、同步 DOM 操作等。 1 2 3 4 useLayoutEffect(() =\u0026gt; { // 这里的代码在 DOM 更新后但在浏览器绘制之前执行 console.log(\u0026#39;Layout effect executed before render\u0026#39;); }, [dependencies]); 2. 性能影响 useEffect：\n由于在浏览器绘制后执行，不会阻塞浏览器的绘制过程，因此对性能影响较小。 适合大多数副作用场景。 useLayoutEffect：\n由于在浏览器绘制之前执行，可能会阻塞浏览器的绘制过程，导致性能下降。 应谨慎使用，尤其是在需要频繁更新的场景中。 3. 使用场景 useEffect：\n数据获取：从 API 获取数据并更新状态。 订阅：设置和清理事件监听器。 动画：在组件更新后启动动画。 useLayoutEffect：\n读取布局信息：在 DOM 更新后立即读取元素的尺寸或位置。 需要同步更新的 DOM 操作：例如，调整元素的样式或位置，确保在浏览器绘制之前完成。 4. 代码示例 使用 useEffect：\n1 2 3 4 5 6 7 8 9 10 11 import React, { useEffect, useState } from \u0026#39;react\u0026#39;; const ExampleComponent = () =\u0026gt; { const [data, setData] = useState(null); useEffect(() =\u0026gt; { fetchData().then(response =\u0026gt; setData(response)); }, []); return \u0026lt;div\u0026gt;{data}\u0026lt;/div\u0026gt;; }; 使用 useLayoutEffect：\n1 2 3 4 5 6 7 8 9 10 11 12 import React, { useLayoutEffect, useRef } from \u0026#39;react\u0026#39;; const LayoutExample = () =\u0026gt; { const divRef = useRef(null); useLayoutEffect(() =\u0026gt; { const height = divRef.current.getBoundingClientRect().height; console.log(\u0026#39;Height:\u0026#39;, height); // 在浏览器绘制之前读取高度 }, []); return \u0026lt;div ref={divRef}\u0026gt;Hello, World!\u0026lt;/div\u0026gt;; }; 总结 useEffect：在浏览器绘制后执行，适合大多数副作用场景，性能影响较小。 useLayoutEffect：在浏览器绘制之前执行，适合需要同步更新的副作用，可能会影响性能。 在选择使用哪个 Hook 时，通常推荐优先使用 useEffect，只有在确实需要在浏览器绘制之前执行某些操作时，才使用 useLayoutEffect。\n说一下react hooks 的执行过程，当它遇到钩子函数（原生钩子以及自定义钩子）时，它会重新执行一遍吗？ 在 React 中，Hooks 组件的执行过程涉及多个步骤，特别是在使用 useEffect 和自定义 Hooks 时。以下是详细的执行过程说明：\n1. 组件的初始渲染 函数组件调用：当组件首次渲染时，React 会调用该函数组件。 执行 Hooks：在组件内部，React 会按顺序执行所有的 Hooks，包括 useState、useEffect 和自定义 Hooks。 1 2 3 4 5 6 7 8 9 const MyComponent = () =\u0026gt; { const [count, setCount] = useState(0); // 初始化状态 useEffect(() =\u0026gt; { console.log(\u0026#39;Effect executed on mount\u0026#39;); }, []); // 仅在组件挂载时执行 return \u0026lt;div\u0026gt;{count}\u0026lt;/div\u0026gt;; }; 2. 组件的更新 状态或属性变化：当组件的状态（通过 setState）或属性发生变化时，React 会重新调用该组件的函数。 重新执行 Hooks：每次组件重新渲染时，所有的 Hooks 都会被重新执行。这意味着 useState 会返回当前状态和更新函数，而 useEffect 的回调函数会在适当的时机执行。 3. useEffect 的执行 初始渲染：在组件首次渲染后，React 会在 DOM 更新完成后执行 useEffect 中的回调函数。 依赖数组：如果 useEffect 的依赖数组为空（[]），则回调函数只会在组件挂载时执行一次。如果依赖数组中有变量，只有当这些变量发生变化时，useEffect 的回调函数才会重新执行。 1 2 3 useEffect(() =\u0026gt; { console.log(\u0026#39;Effect executed on count change\u0026#39;); }, [count]); // 仅在 count 变化时执行 4. 自定义 Hooks 的执行 自定义 Hooks：自定义 Hooks 是一个函数，可以调用其他 Hooks。每次组件重新渲染时，自定义 Hooks 也会被重新执行。 1 2 3 4 5 6 7 8 9 10 const useCustomHook = () =\u0026gt; { const [value, setValue] = useState(0); // 其他逻辑 return [value, setValue]; }; const MyComponent = () =\u0026gt; { const [customValue, setCustomValue] = useCustomHook(); // 自定义 Hook // 组件逻辑 }; 5. 清理副作用 清理函数：如果 useEffect 返回一个清理函数，React 会在组件卸载或依赖项变化时调用该清理函数。这使得可以在组件卸载时清理副作用（如取消订阅、清除定时器等）。 1 2 3 4 5 6 7 8 9 useEffect(() =\u0026gt; { const timer = setTimeout(() =\u0026gt; { console.log(\u0026#39;Timer executed\u0026#39;); }, 1000); return () =\u0026gt; { clearTimeout(timer); // 清理定时器 }; }, []); 6. 组件卸载 卸载过程：当组件从 UI 中移除时，React 会调用 useEffect 中的清理函数（如果有），并且组件的状态和 Hooks 会被清除。 总结 每次组件重新渲染时，所有的 Hooks（包括 useEffect 和自定义 Hooks）都会被重新执行。 useEffect 的回调函数在组件挂载后执行，并根据依赖数组的变化决定是否重新执行。 自定义 Hooks 也会在每次渲染时被重新调用，允许在多个组件之间共享逻辑。 清理函数在组件卸载或依赖项变化时执行，确保副作用的正确管理。 这种机制使得 React 的 Hooks 组件能够灵活地管理状态和副作用，同时保持代码的简洁性和可读性。\n","date":"2020-09-09T00:00:00Z","permalink":"https://trinyoung.github.io/interview/p/test-chinese/","title":"react hooks 面试题2"},{"content":"1. vue 中keepAlive 的原理 在 Vue 中，keep-alive 是一个内置组件，用于缓存不活动的组件实例，从而在它们重新激活时避免重新渲染。这个功能特别适合需要在不同视图之间切换时保留组件状态的场景，如路由组件切换时保留表单输入数据、滚动位置等。\nkeep-alive 的工作原理 keep-alive 组件通过以下机制实现组件的缓存和复用：\n组件缓存：\n当某个组件被包裹在 keep-alive 中，并且被移除（如路由切换、条件渲染），keep-alive 不会销毁这个组件的实例，而是将其缓存起来。 当该组件再次被激活时，keep-alive 会直接从缓存中取出组件实例，而不是重新创建和渲染组件。这样可以节省性能开销。 缓存管理：\nkeep-alive 通过 cache 和 keys 属性来管理缓存的组件实例。 cache 是一个对象，存储了所有被缓存的组件实例。它的键是组件的 key 或 cid（组件的唯一标识符）。 keys 是一个数组，记录了缓存中的组件键的顺序，keep-alive 通过这个顺序来决定哪个组件需要被缓存或移除。 生命周期钩子：\n被 keep-alive 缓存的组件实例不会触发 created、mounted 等生命周期钩子。但会新增两个生命周期钩子： activated: 当组件从缓存中激活时触发。 deactivated: 当组件被缓存且移除时触发。 keep-alive 的常用属性 include：允许的组件名（或正则表达式），只有匹配的组件才会被缓存。 exclude：排除的组件名（或正则表达式），匹配的组件不会被缓存。 max：缓存的最大组件实例数目，超过这个数目时，最先缓存的组件实例将被移除。 使用示例 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;keep-alive include=\u0026#34;MyComponent\u0026#34; max=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/keep-alive\u0026gt; \u0026lt;/template\u0026gt; 简单的示意代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 这是 keep-alive 组件内部的简化示意 class KeepAlive { constructor() { this.cache = Object.create(null); // 用于缓存组件实例 this.keys = []; // 用于记录缓存的键的顺序 } cacheVNode(key, vnode) { this.cache[key] = vnode; this.keys.push(key); } pruneCacheEntry(key) { const cachedVNode = this.cache[key]; if (cachedVNode) { cachedVNode.componentInstance.$destroy(); // 销毁实例 delete this.cache[key]; this.keys.splice(this.keys.indexOf(key), 1); } } } 总结 keep-alive 的缓存是存储在 Vue 的内存中的，而不是存储在浏览器的本地存储或其他持久化存储中。具体来说，keep-alive 组件实例中维护的 cache 对象和 keys 数组，负责管理和存储这些缓存的组件实例。当需要重新渲染组件时，Vue 会从 cache 中取出对应的 VNode，从而避免重复的组件实例创建和渲染。\n2. vue 中diff算法的原理 Vue 中的 diff 算法是其虚拟 DOM (VNode) 实现的核心部分，用于高效地更新视图。它的基本思想是通过比较新旧两个虚拟 DOM 树，找出最小的变更集，然后在真实 DOM 上进行最小量的操作，从而优化性能。\nDiff 算法的核心思想 同层比较：\nVue 的 diff 算法只会对比同层级的节点，而不会跨层级比较。因为跨层级的移动或者比较成本非常高，所以 Vue 的 diff 算法会假设不同层级的 DOM 结构差异不会太大。 双端比较：\nVue 使用了一种双端比较算法，从前后两端同时进行比较，从而提高了效率。具体步骤如下： 从头开始比较：首先比较新旧虚拟 DOM 树的第一个节点，如果相同就继续向下比较，如果不同则停止。 从尾开始比较：接着从两棵树的尾部开始比较，如果相同则继续向前比较，如果不同则停止。 如果中间有差异：Vue 会尝试通过查找旧节点中的 key 来确认新节点是否在旧节点中已经存在，如果存在则移动节点，如果不存在则创建新节点。 同类型节点的更新：\n如果两个节点是相同类型（即标签相同），Vue 会继续比较他们的属性和子节点，找出需要更新的地方。 删除、创建、移动节点：\n删除：如果旧虚拟 DOM 树中的某个节点在新虚拟 DOM 树中不存在，那么这个节点会被删除。 创建：如果新虚拟 DOM 树中出现了旧虚拟 DOM 树中没有的节点，Vue 会创建这个新节点。 移动：如果发现相同的节点在新旧虚拟 DOM 树中的位置不同，Vue 会移动这个节点。 优化：通过 key 提升性能：\nVue 建议为列表中的节点提供唯一的 key，这样可以使得 Vue 在 diff 的过程中能更准确地找到对应节点，提高更新效率。 如果没有 key，Vue 会采用一种“就地复用”的策略，即如果两个节点是同一类型的，它们会被认为是同一个节点，即使它们在实际内容上不同。 Diff 算法的具体步骤 假设有两棵虚拟 DOM 树：oldVNode 和 newVNode。\n比较根节点：\n首先比较 oldVNode 和 newVNode 的根节点，如果节点类型不同，直接替换整个节点。 比较子节点：\n如果根节点类型相同，则进入子节点的比较。如果子节点有 key 属性，会基于 key 进行比对，否则基于节点的位置和类型。 同层比较：\n在同一层级中，Vue 使用双端比较法（先从头到尾，再从尾到头）找出可以复用的节点。 递归更新：\n对于每一个节点，Vue 递归地对子节点进行相同的 diff 操作。 处理边界情况：\n如果旧节点比新节点多，Vue 会删除多余的旧节点。 如果新节点比旧节点多，Vue 会创建新的节点并插入。 Diff 算法的复杂度 在最理想的情况下，Vue 的 diff 算法的复杂度为 O(n)，其中 n 是节点数量。但如果节点结构差异较大，可能会接近 O(n^2)，因此 Vue 强烈建议开发者在有序列表中使用 key 以提升 diff 算法的性能。\n总结 Vue 的 diff 算法通过同层比较、双端比较以及递归地处理子节点，来确保 DOM 更新的最小化操作。合理使用 key 可以进一步提升 diff 算法的效率，从而在真实 DOM 中高效地反映虚拟 DOM 的变化。\n3. vue 的核心概念是什么？ 1. 数据驱动视图 Vue 的核心理念之一是“数据驱动视图”，即视图层是由数据层驱动的。\n响应式数据绑定：\nVue 采用双向数据绑定（Two-Way Data Binding），通过 data 选项定义的数据属性和视图之间建立自动的绑定关系。任何对数据的更新都会自动反映在视图中，而用户在视图中的操作也能即时更新数据。 Vue 的响应式系统是基于 Object.defineProperty（Vue 2）或 Proxy（Vue 3）实现的。当数据发生变化时，Vue 的依赖追踪系统会自动侦测到并触发相应的视图更新。 声明式渲染：\nVue 使用模板语法，让开发者可以声明式地定义 UI。模板中的表达式会动态绑定到 Vue 实例中的数据，开发者只需专注于数据本身，而无需直接操作 DOM。 这种方式降低了操作 DOM 的复杂性，提升了开发效率和代码的可维护性。 2. 组件化 “组件化”是 Vue 的另一核心思想，它允许开发者将应用拆分为独立、可复用的小块（组件），每个组件负责特定的功能或 UI 部分。\n组件封装：\n每个组件包含了自己的模板、逻辑和样式，使得组件内部的实现细节对外部是封装的。这样，开发者可以轻松地维护和复用组件，减少代码重复。 组件组合：\nVue 应用通常是通过多个组件的组合构建起来的。通过父子组件的组合和传递 props 及事件，可以构建出复杂的用户界面。 单文件组件 (SFC)：\nVue 提供了单文件组件的开发方式（.vue 文件），将模板、逻辑和样式集中在一个文件中。SFC 使得组件的开发、维护和复用变得更加方便。 3. 其他核心概念 除了以上两大核心思想，Vue 还具备以下重要的核心概念：\n渐进式框架：\nVue 是一个渐进式框架，这意味着你可以根据需求从轻量级的视图库逐步扩展到功能完备的前端框架。Vue 可以与其他库或现有项目轻松集成，也可以单独用于构建复杂的单页面应用 (SPA)。 生态系统：\nVue 的生态系统非常丰富，包括 Vue Router（路由管理）、Vuex（状态管理）等，这些工具帮助开发者在不同的场景下有效管理应用的复杂性。 虚拟 DOM：\nVue 使用虚拟 DOM 技术来提升性能。通过比较虚拟 DOM 树的差异（diff），Vue 可以智能地决定最小化的 DOM 操作，从而高效地更新视图。 总结 Vue 的核心思想是通过数据驱动视图，结合组件化的方式，帮助开发者构建高效、可维护、可复用的用户界面。Vue 的响应式数据系统和渐进式特性，使得它既适合小型项目，也能胜任复杂的单页面应用。\n4. vue 的双向绑定的原理是什么？vue2和vue3的区别是什么？ Vue 的数据双向绑定是 Vue 框架的核心特性之一，它使得数据和视图之间保持同步，即数据的变化会自动反映到视图上，而用户在视图上的操作也会自动更新数据。Vue 2 和 Vue 3 在实现数据双向绑定的方式上有一些不同，下面我将分别介绍它们的原理及差异。\nVue 2 的数据双向绑定原理 Vue 2 的数据双向绑定主要依赖于 Object.defineProperty，通过劫持对象属性的 getter 和 setter 来实现数据的响应式。\n1. Observer 监听器 Vue 2 中，当一个 Vue 实例被创建时，Vue 会遍历 data 对象中的所有属性，并使用 Object.defineProperty 将这些属性转为 getter 和 setter。 通过这些 getter 和 setter，Vue 可以在数据被访问时（通过 getter）或修改时（通过 setter）进行额外的操作，比如依赖收集和派发更新。 2. Dep 和 Watcher Dep：每个被观察的属性（即每个 data 中的属性）都有一个依赖管理器（Dep），负责收集依赖于这个属性的所有“观察者” (Watcher)。 Watcher：Watcher 是一个观察者对象，负责监听属性的变化。当属性发生变化时，Watcher 会触发视图的更新。 3. 数据流动 当组件的模板被渲染时，模板中的数据会触发属性的 getter，从而触发依赖收集（Dep 将 Watcher 收集起来）。 当数据发生变化时（即属性的 setter 被触发），Vue 会通知对应的 Watcher，Watcher 随后通知视图进行重新渲染。 局限性 Vue 2 的实现方式基于 Object.defineProperty，它无法直接监听数组的变化，也无法直接监听对象属性的添加和删除，因此 Vue 2 需要通过一些特殊方法（如 Vue.set、Vue.delete）来处理这些情况。 Vue 3 的数据双向绑定原理 Vue 3 引入了 Proxy 对象，取代了 Vue 2 中的 Object.defineProperty，以实现更为强大和灵活的数据双向绑定。\n1. Proxy 与 Reflect Vue 3 中，响应式数据的核心是 Proxy，它能够直接拦截对象的所有操作，包括读取、写入、删除属性等。这意味着 Vue 3 能够监听数组的变化以及对象属性的动态添加和删除。 Vue 3 使用 Proxy 代理了 data 对象，并通过 Reflect 来处理代理对象的默认行为。 2. Reactivity 模块 Vue 3 的响应式系统是基于一个独立的 Reactivity 模块实现的，这个模块包含了 reactive、ref、computed 等 API，允许开发者以更加灵活的方式创建响应式数据。 通过 reactive，Vue 3 可以将一个普通对象转为响应式对象，类似于 Vue 2 中的 data。 3. 依赖追踪和触发 Vue 3 的依赖追踪和触发更新机制与 Vue 2 类似，都是通过依赖收集（依赖于数据的组件或方法会被收集）和触发更新（当数据改变时通知依赖的组件或方法进行更新）来实现的。 由于 Proxy 的强大功能，Vue 3 可以更精细地追踪变化，避免了 Vue 2 中的一些局限性，比如对数组操作的监测问题。 Vue 2 与 Vue 3 的主要区别 实现方式：\nVue 2 使用 Object.defineProperty 实现数据双向绑定，Vue 3 使用 Proxy 来实现更为强大和灵活的响应式系统。 响应式系统的灵活性：\nVue 3 的 Proxy 可以直接监听数组的变化、对象属性的添加和删除等操作，避免了 Vue 2 的局限性。 Vue 3 的响应式 API（如 reactive、ref）提供了更多的控制和灵活性。 性能：\nVue 3 的响应式系统在性能上有了很大的提升，特别是在大规模数据操作和复杂的组件树结构中，Vue 3 表现得更为高效。 代码结构和模块化：\nVue 3 的响应式系统是一个独立的模块，允许更好的树摇优化（tree-shaking），减小打包体积。 总结 Vue 的数据双向绑定是通过数据的响应式系统实现的，Vue 2 使用 Object.defineProperty，而 Vue 3 则使用 Proxy 来实现。Vue 3 的实现方式更加灵活和强大，解决了 Vue 2 中的一些局限性，同时也带来了更好的性能和开发体验。\n5. vue 的生命周期有哪些？ Vue 的生命周期钩子函数是指在 Vue 实例的各个不同阶段执行的函数。这些钩子函数允许开发者在 Vue 实例的不同生命周期阶段执行自定义的代码。Vue 2 和 Vue 3 的生命周期钩子基本一致，以下是主要的生命周期钩子函数及其触发时机：\n1. 创建阶段（Creation Phase） beforeCreate：实例初始化之后，数据观测 (data observer) 和事件配置还未完成。在这个阶段，data 和 props 还没有被初始化，因此在这个钩子中无法访问 data 和 props。\ncreated：实例创建完成，完成数据观测、属性与方法的初始化，data、props 等都可以访问。此时尚未挂载到 DOM 中，也没有生成 $el。\n2. 挂载阶段（Mounting Phase） beforeMount：在挂载开始之前被调用，相关的 render 函数首次被调用。在这个阶段，虚拟 DOM 已经创建，但尚未渲染到实际的 DOM 上。\nmounted：实例挂载到 DOM 后调用，此时 el 被新创建的 vm.$el 替换。此时组件已被挂载到页面上，DOM 操作可以在这里进行。\n3. 更新阶段（Updating Phase） beforeUpdate：响应式数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁 (patch) 之前。在这个钩子中，可以访问到更新前的 DOM。\nupdated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。此时组件 DOM 已经更新，因此可以执行基于新 DOM 的操作。\n4. 销毁阶段（Destruction Phase） beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。\ndestroyed：实例销毁后调用。调用后，Vue 实例的所有指令绑定和事件监听器都会被解除，所有子实例也会被销毁。\n5. Vue 3 特有的生命周期钩子 Vue 3 引入了与组合式 API（Composition API）一起使用的生命周期钩子函数，这些函数与 Vue 2 中的钩子作用相同，但命名更具可读性，并且使用更灵活。\nonBeforeMount：等同于 Vue 2 的 beforeMount。 onMounted：等同于 Vue 2 的 mounted。 onBeforeUpdate：等同于 Vue 2 的 beforeUpdate。 onUpdated：等同于 Vue 2 的 updated。 onBeforeUnmount：等同于 Vue 2 的 beforeDestroy。 onUnmounted：等同于 Vue 2 的 destroyed。 这些钩子函数可以在 Vue 3 的组合式 API 中使用，例如在 setup 函数中调用。\n总结 Vue 的生命周期提供了一个从创建、挂载、更新到销毁的完整流程的钩子函数，让开发者可以在每个关键节点执行相应的操作。了解和使用这些钩子函数，可以帮助更好地控制组件的行为，处理复杂的逻辑或优化性能。\n6. vue 的组件通信方式有哪些？ 在 Vue 中，组件之间的通信方式有多种，具体选择哪种方式取决于组件之间的关系（如父子关系、兄弟关系）以及数据流的复杂度。以下是 Vue 组件之间常见的通信方式：\n1. 父子组件通信 1.1 Props 传递 父组件通过 props 向子组件传递数据。这是 Vue 中最常用的通信方式之一。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- 父组件 --\u0026gt; \u0026lt;ChildComponent :message=\u0026#34;parentMessage\u0026#34; /\u0026gt; \u0026lt;!-- 子组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ message }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#39;message\u0026#39;] } \u0026lt;/script\u0026gt; 1.2 Event 触发 子组件可以通过 $emit 触发事件，父组件监听事件来接收数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!-- 子组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;Send Message\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { sendMessage() { this.$emit(\u0026#39;message-sent\u0026#39;, \u0026#39;Hello from child\u0026#39;); } } } \u0026lt;/script\u0026gt; \u0026lt;!-- 父组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;ChildComponent @message-sent=\u0026#34;receiveMessage\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { receiveMessage(msg) { console.log(msg); } } } \u0026lt;/script\u0026gt; 2. 兄弟组件通信 2.1 通过父组件作为中介 兄弟组件可以通过父组件传递数据。例如，一个兄弟组件通过 Event 传递数据给父组件，父组件再将数据通过 Props 传递给另一个兄弟组件。\n2.2 事件总线 (Event Bus) 创建一个空的 Vue 实例作为事件总线，兄弟组件可以通过这个总线来通信。不过在 Vue 3 中，建议使用其他方式替代事件总线。\n1 2 3 4 5 6 7 8 9 10 11 // eventBus.js import Vue from \u0026#39;vue\u0026#39;; export const EventBus = new Vue(); // 兄弟组件A EventBus.$emit(\u0026#39;event-name\u0026#39;, data); // 兄弟组件B EventBus.$on(\u0026#39;event-name\u0026#39;, (data) =\u0026gt; { console.log(data); }); 2.3 Vuex (状态管理) 在复杂应用中，可以使用 Vuex 进行状态管理。兄弟组件可以通过 Vuex 共享状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // store.js export const store = new Vuex.Store({ state: { message: \u0026#39;\u0026#39; }, mutations: { setMessage(state, msg) { state.message = msg; } } }); // 兄弟组件A this.$store.commit(\u0026#39;setMessage\u0026#39;, \u0026#39;Hello from A\u0026#39;); // 兄弟组件B computed: { message() { return this.$store.state.message; } } 3. 跨层级组件通信 3.1 Provide 和 Inject Provide 和 Inject 允许父组件向任意层级的后代组件提供数据，而不必通过 Props 层层传递。\n1 2 3 4 5 6 7 8 9 10 11 // 父组件 export default { provide: { message: \u0026#39;Hello World\u0026#39; } } // 任意层级的子组件 export default { inject: [\u0026#39;message\u0026#39;] } 3.2 Vuex 同样地，Vuex 也可以用于跨层级的组件通信，通过集中管理状态来实现跨层级的数据共享。\n4. 其他通信方式 4.1 $attrs 和 $listeners 父组件向子组件传递属性和事件，适用于高阶组件（Higher-order components）。\n4.2 $parent 和 $children 通过访问组件实例的 $parent 和 $children 来通信，但这种方式不推荐使用，因为它会导致组件之间的耦合性增加。\n4.3 Ref 和 $refs 通过 ref 获取子组件的实例，从而访问或调用子组件的方法和属性。\n1 2 3 4 5 6 \u0026lt;!-- 父组件 --\u0026gt; \u0026lt;ChildComponent ref=\u0026#34;child\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; this.$refs.child.someMethod(); \u0026lt;/script\u0026gt; 总结 Vue 提供了多种组件通信方式，适用于不同的场景和复杂度。在选择通信方式时，应考虑组件之间的关系、数据流的复杂度以及应用的规模，尽量保持代码的简洁性和可维护性。\n7. vue 的路由模式有哪些？ Vue 的路由模式是指在 Vue 应用中定义路由的方式，包括 hash 模式和 history 模式。\n1. Hash 模式 Hash 模式是 Vue 路由的默认模式，使用 URL 中的哈希值（#）来表示路由。例如，访问 URL_ADDRESS 会将 #/about` 作为哈希值，并将其作为路由。\n1 2 3 4 5 6 7 8 9 // 路由配置 const router = new VueRouter({ routes: [ { path: \u0026#39;/\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, component: About } ] }) // 访问 URL_ADDRESS/#/about 优点 兼容性好，支持所有浏览器。 易于分享，因为 URL 中没有 #，因此可以轻松分享链接。 缺点 不利于 SEO，因为哈希值不会被包含在搜索引擎的索引中。 不利于后端路由，因为哈希值不会被发送到服务器。 不利于前端路由，因为哈希值的变化不会触发页面的刷新。 2. History 模式 History 模式使用 HTML5 的 History API 来实现路由，它通过修改 URL 来实现路由跳转，从而避免了使用哈希值。\n1 2 3 4 5 6 7 8 9 10 // 路由配置 const router = new VueRouter({ mode: \u0026#39;history\u0026#39;, routes: [ { path: \u0026#39;/\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, component: About } ] }) // 访问 URL_ADDRESS/about 优点 易于分享，因为 URL 中没有 #，因此可以轻松分享链接。 支持后端路由，因为服务器可以根据 URL 来返回相应的页面。 支持前端路由，因为 URL 的变化会触发页面的刷新。 缺点 兼容性稍差，需要浏览器支持 HTML5 的 History API。 不利于 SEO，因为 URL 中没有 #，搜索引擎会认为这是一个普通的 URL，而不是锚点。 总结 Vue 的路由模式包括 hash 模式和 history 模式。hash 模式使用 URL 中的哈希值（#）来表示路由，而 history 模式使用 HTML5 的 History API 来实现路由。选择哪种模式取决于应用的需求和使用场景。\n8. vue 的路由守卫有哪些？ Vue 的路由守卫是指在路由跳转过程中执行的钩子函数，可以用来实现路由的权限控制、数据预加载等功能。Vue 提供了多种路由守卫，包括全局守卫、路由独享守卫和组件内守卫。\n1. 全局守卫 全局守卫是指在路由跳转过程中，无论路由是跳转到哪个路由，都会执行的钩子函数。\n1 2 3 4 5 6 7 8 9 10 // 全局前置守卫 router.beforeEach((to, from, next) =\u0026gt; { // 在跳转到目标路由之前执行的操作 next(); }); // 全局后置守卫 router.afterEach((to, from) =\u0026gt; { // 在跳转到目标路由之后执行的操作 }); 2. 路由独享守卫 路由独享守卫是指在特定的路由上执行的钩子函数，可以用来实现路由的权限控制、数据预加载等功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 路由独享前置守卫 const router = new VueRouter({ routes: [ { path: \u0026#39;/about\u0026#39;, component: About, beforeEnter: (to, from, next) =\u0026gt; { // 在跳转到 /about 路由之前执行的操作 next(); } } ] }); // 路由独享后置守卫 const router = new VueRouter({ routes: [ { path: \u0026#39;/about\u0026#39;, component: About, afterEnter: (to, from) =\u0026gt; { // 在跳转到 /about 路由之后执行的操作 } } ] }); 3. 组件内守卫 组件内守卫是指在组件内定义的钩子函数，可以用来实现组件内的权限控制、数据预加载等功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 组件内前置守卫 const Foo = { template: `\u0026lt;div\u0026gt;Foo\u0026lt;/div\u0026gt;`, beforeRouteEnter (to, from, next) { // 在跳转到该组件路由之前执行的操作 next(); } } // 组件内后置守卫 const Foo = { template: `\u0026lt;div\u0026gt;Foo\u0026lt;/div\u0026gt;`, beforeRouteLeave (to, from, next) { // 在离开该组件路由之前执行的操作 next(); } } 4. 路由元信息 路由元信息是指在路由配置中定义的额外信息，可以用来实现路由的权限控制、数据预加载等功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 路由配置 const router = new VueRouter({ routes: [ { path: \u0026#39;/about\u0026#39;, component: About, meta: { requiresAuth: true, // 需要登录权限 requiresAdmin: true // 需要管理员权限 } } ] }); // 路由守卫 router.beforeEach((to, from, next) =\u0026gt; { if (to.meta.requiresAuth \u0026amp;\u0026amp; !isAuthenticated()) { // 如果需要登录权限，且用户未登录，则跳转到登录页面 next({ path: \u0026#39;/login\u0026#39; }); } else if (to.meta.requiresAdmin \u0026amp;\u0026amp; !isAdmin()) { // 如果需要管理员权限，且用户不是管理员，则跳转到 403 页面 next({ path: \u0026#39;/403\u0026#39; }); } else { // 如果不需要权限或权限验证通过，则继续跳转 next(); } }); 5. 导航守卫的执行顺序 导航守卫的执行顺序是：全局前置守卫 -\u0026gt; 路由独享前置守卫 -\u0026gt; 组件内前置守卫 -\u0026gt; 全局后置守卫 -\u0026gt; 路由独享后置守卫 -\u0026gt; 组件内后置守卫。\n6. 总结 Vue 的路由守卫提供了多种方式来实现路由的权限控制、数据预加载等功能。全局守卫、路由独享守卫和组件内守卫可以根据需要进行配置，路由元信息可以用来定义路由的额外信息。导航守卫的执行顺序是：全局前置守卫 -\u0026gt; 路由独享前置守卫 -\u0026gt; 组件内前置守卫 -\u0026gt; 全局后置守卫 -\u0026gt; 路由独享后置守卫 -\u0026gt; 组件内后置守卫。\n9. vue 的路由懒加载有哪些方式？ Vue 的路由懒加载是指在路由配置中使用动态导入的方式来加载路由组件，从而减少应用的初始加载时间。Vue 提供了多种方式来实现路由懒加载，包括异步组件、异步路由组件和异步路由。\n1. 异步组件 异步组件是指在路由配置中使用 import() 函数来动态导入路由组件，从而实现路由懒加载。\n1 2 3 4 5 6 7 8 9 // 路由配置 const router = new VueRouter({ routes: [ { path: \u0026#39;/about\u0026#39;, component: () =\u0026gt; import(\u0026#39;./views/About.vue\u0026#39;) } ] }); 2. 异步路由组件 异步路由组件是指在路由配置中使用 component 属性来定义异步路由组件，从而实现路由懒加载。\n1 2 3 4 5 6 7 8 9 // 路由配置 const router = new VueRouter({ routes: [ { path: \u0026#39;/about\u0026#39;, component: () =\u0026gt; import(\u0026#39;./views/About.vue\u0026#39;) } ] }); 3. 异步路由 异步路由是指在路由配置中使用 children 属性来定义异步路由，从而实现路由懒加载。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 路由配置 const router = new VueRouter({ routes: [ { path: \u0026#39;/about\u0026#39;, component: About, children: [ { path: \u0026#39;child1\u0026#39;, component: () =\u0026gt; import(\u0026#39;./views/Child1.vue\u0026#39;) }, { path: \u0026#39;child2\u0026#39;, component: () =\u0026gt; import(\u0026#39;./views/Child2.vue\u0026#39;) } ] } ] }); 10. vue 路由的原理是什么？ 创建的页面路由会与该页面形成一个路由表（key value形式，key为该路由，value为该路由对应的页面组件）； vue-router 会监听浏览器地址栏的变化，并将地址栏的值与路由表进行匹配，匹配成功后，将对应的页面组件渲染到页面中； 然而当浏览器的中的路径发生变化时，它会向服务器请求资源，为了避免这种情况，vue 采用了两种方式来避免这种情况的发生： hash 和 history； hash 模式：hash 模式是通过在 URL 的末尾添加一个哈希值（#）来实现的，例如：`URL_ADDRESS URL 中的哈希值发生变化时，浏览器不会向服务器发送请求，而是通过 JavaScript 来处理哈希值的变化，从而实现页面的跳转。 history 模式：利用了pushState() 和replaceState() 方法，实现往history中添加新的浏览记录、或替换对应的浏览记录。但是设置了history模式，需要 11. vue3 中的reactive 和 ref 的区别？ 1. 数据类型 ref主要用于创建基本数据类型的响应式数据（如字符串，数字，布尔值等），也可以用来包装一个引用类型的数据（如对象或数组）。当使用 ref 包装数据时，访问或修改这个数据需要通过 .value 属性。 reactive 则直接将一个对象或者数据变成响应式的，不需要通过 .value 属性访问或修改。可以直接使用对象属性或数组方法。 2. 追踪依赖 使用 ref 创建的响应式数据，内部会转换成一个对象，并且添加了一个 .value 属性。这意味着在模板中或者计算属性中使用它时，需要以 .value 的形式来访问。 reactive 直接返回原始对象，因此可以像操作普通对象一样操作它，这使得它在处理复杂数据结构时更为方便。 3. 深层响应式 ref 只能包装一层数据，如果要包装多层数据，需要使用 ref 包装每层数据，例如：ref({a:1,b:{c:2}})。 reactive 默认会递归地让对象内部的所有属性都变成响应式的，即它是深层响应式的。 4. 性能考虑 对于大量的对象或复杂的嵌套数据结构，使用 reactive 可能会更高效，因为它避免了 ref 需要多次调用 .value 的问题。 对于简单的数据，如字符串、数字、布尔值等，使用 ref 可能更方便，因为它不需要额外的开销。ref 更适合单个值或简单数据结构的响应式处理。 5. 使用场景 ref 更适合用于那些会被用在不同作用域中的数据，或者是需要在组件之间共享的状态管理。 reactive 更适合用于那些需要深度响应式处理的数据，例如对象和数组等。 总结来说 总结来说，选择 ref 还是 reactive 主要看具体的应用场景和个人偏好。对于简单的值或者需要在多个组件间共享的状态，ref 可能更加合适；而对于复杂的对象结构或者组件内部的状态管理，reactive 通常更加方便。\n12. vue3 中的reactive 是如何实现的？ 在 Vue 3 中，reactive 是通过 Proxy 对象来实现的。当使用 reactive 创建一个对象时，Vue 会创建一个 Proxy 对象，并将其作为返回值。这个 Proxy 对象将拦截对对象的所有操作，包括读取和写入属性，并通过调用对应的响应式函数来处理。这样，当我们访问或修改这个对象的属性时，Vue 会自动更新视图。\n13. vue3 中的ref 是如何实现的？ 在 Vue 3中，ref 是通过 createRef 函数来实现的。这个函数接受一个参数，这个参数可以是一个基本数据类型（如字符串、数字、布尔值等）或者是一个对象。如果参数是一个对象，那么 createRef 将返回一个对象，该对象有一个 .value 属性，用于访问或修改原始对象。如果参数是一个基本数据类型，那么 createRef 将返回一个对象，该对象有一个 .value 属性，用于访问或修改原始数据。\n14. vue2 中，数据双向绑定为什么使用的Object.defineProperty 而不是Object.defineProperties? 主要原因在于以下几个方面：\n递归劫持 vs 单次批量定义 在 Vue 2 的响应式系统中，不仅仅是对对象的顶层属性进行劫持，还需要递归地劫持嵌套的对象属性。例如，对于一个深层嵌套的对象，Vue 2 需要递归遍历每一层属性，对每个属性都单独进行 Object.defineProperty 操作。这种递归操作要求灵活性，因为 Vue 不仅要处理简单对象，还要处理数组、嵌套对象等复杂结构。 Object.defineProperty 允许逐个属性地进行递归劫持，这使得 Vue 可以处理每个属性、每一层级的递归操作。 Object.defineProperties 则是一次性定义多个属性，缺少了递归的机制。如果使用 Object.defineProperties，当一个属性是嵌套对象时，无法方便地递归对嵌套属性进行响应式处理。 2. 数组和对象的特殊处理 Vue 2 对数组和对象的响应式处理方式不同。Vue 2 使用 Object.defineProperty 来对对象的属性进行拦截，但对数组的操作（比如 push、pop 等方法）则是通过函数重写的方式来进行劫持。如果使用 Object.defineProperties，在处理数组时并不适用。\n灵活性 Object.defineProperty 的逐个属性劫持方法非常灵活，可以在处理不同类型的数据结构（比如数组、对象、普通数据类型）时进行细粒度的控制。例如，如果一个属性是对象，Vue 会递归进行深层的劫持；而如果一个属性是原始类型（比如 number 或 string），Vue 就不会递归。这种灵活的处理方式在 Vue 的数据响应式设计中是非常关键的。\n性能考虑 虽然 Object.defineProperties 允许一次性定义多个属性，但 Vue 的数据响应式系统需要对每一个属性进行深度处理。如果使用 Object.defineProperties，在递归嵌套对象时，依然需要在每层都调用它，这会增加性能上的开销。相反，Object.defineProperty 可以让 Vue 更加精细化地控制每个属性的处理和递归。\n每个属性的特殊拦截逻辑 虽然大部分属性的 getter 和 setter 逻辑是一样的，但 Vue 在某些情况下需要对特定属性进行特殊处理。比如对于数组的某些变更方法（如 push、pop），Vue 需要重写这些方法，以确保数组变更能被检测到。这种情况下，Object.defineProperty 逐个属性地定义 getter 和 setter 更加灵活。\n总结 Vue 2 使用 Object.defineProperty 而不是 Object.defineProperties，是因为 Vue 的响应式系统需要递归处理深层嵌套的对象，还要处理不同类型的数据结构（比如数组）。Object.defineProperty 可以逐个属性地进行递归、灵活地处理嵌套对象和数组变更。而 Object.defineProperties 虽然允许一次性定义多个属性，但在 Vue 这样的响应式系统中不具备足够的灵活性，也无法处理递归的复杂场景。\n所以，Vue 选择 Object.defineProperty 主要是出于灵活性、递归深层嵌套处理和性能上的考虑。\n15. proxy 相对于 Object.defineProperty 有哪些优势？ Proxy 相对于 Object.defineProperty 确实有许多优势。让我们详细比较一下：\n更全面的拦截能力：\nProxy 可以拦截多达 13 种不同的基本操作，包括属性查找、赋值、删除、函数调用等。 Object.defineProperty 主要用于拦截属性的读取（get）和设置（set）操作。 数组操作：\nProxy 可以直接监听数组的变化，包括通过索引设置元素、修改数组长度等操作。 Object.defineProperty 无法直接监听数组索引和长度的变化，需要额外的包装和处理。 动态属性：\nProxy 可以监听整个对象，包括新添加的属性。 Object.defineProperty 只能监听对象的已存在属性，新添加的属性需要额外处理。 性能：\n对于大型对象，Proxy 可能会有更好的性能，因为它不需要递归遍历对象的所有属性。 Object.defineProperty 需要遍历对象的每个属性并为其设置 getter 和 setter，这在大型对象上可能会有性能问题。 更简洁的代码：\nProxy 的使用通常leads to更简洁、更易于理解的代码。 Object.defineProperty 往往需要更多的样板代码，特别是在处理嵌套对象时。 原始对象不被修改：\nProxy 创建一个原始对象的代理，不直接修改原始对象。 Object.defineProperty 直接修改原始对象。 可撤销代理：\nProxy 提供 Proxy.revocable()，允许创建可撤销的代理。 Object.defineProperty 没有类似的功能。 更好的错误捕获：\nProxy 可以捕获并抛出更多类型的错误，提供更好的调试体验。 支持更多数据类型：\nProxy 可以代理各种类型的对象，包括数组、函数、甚至是 DOM 节点。 Object.defineProperty 主要用于对象的属性。 元编程能力：\nProxy 提供了强大的元编程能力，允许你自定义对象的基本行为。 示例对比：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 使用 Object.defineProperty let obj = { a: 1 }; Object.defineProperty(obj, \u0026#39;a\u0026#39;, { get() { console.log(\u0026#39;Getting a\u0026#39;); return this._a; }, set(newVal) { console.log(\u0026#39;Setting a\u0026#39;); this._a = newVal; } }); // 使用 Proxy let obj = { a: 1 }; let proxy = new Proxy(obj, { get(target, property) { console.log(`Getting ${property}`); return target[property]; }, set(target, property, value) { console.log(`Setting ${property}`); target[property] = value; return true; } }); 在这个例子中，Proxy 版本可以拦截所有属性的访问和设置，而不仅仅是 \u0026lsquo;a\u0026rsquo;。\n总的来说，Proxy 提供了更强大、更灵活的对象操作拦截能力，这也是为什么 Vue 3 选择使用 Proxy 来重写其响应式系统的原因。然而，Proxy 的一个主要缺点是它不支持 IE 浏览器，这在某些需要兼容旧版浏览器的项目中可能是一个问题。\n16. vue 相对于 react 有哪些优势？ 相对于 React，Vue 在方法层面具有以下优势：\n1. 更简洁的模板语法 Vue 使用的是模板语法（Template），它类似于 HTML，可以让开发者直观地绑定数据和事件。Vue 的模板语法对大部分前端开发者来说更加容易上手，因为它使用的是基于现有 HTML 扩展的语法，像指令（v-bind, v-model, v-if）等来实现功能。 React 采用 JSX 语法，虽然功能强大，但对不熟悉 JavaScript 扩展语法的开发者来说，可能不太直观。React 通过在 JavaScript 中混合 HTML 元素来构建视图，开发者需要更多地掌握 JavaScript。 2. 双向数据绑定 Vue 默认支持 双向数据绑定，通过 v-model 可以非常方便地实现表单数据的双向同步，尤其在表单处理和用户输入交互上表现得更为简洁。Vue 的双向绑定通过 getter 和 setter 自动更新 DOM。 React 不提供内置的双向数据绑定，开发者需要手动管理表单控件的状态，处理表单数据同步的逻辑，通常需要写更多的代码。 3. 计算属性（Computed Properties） Vue 提供了计算属性（computed），用于基于已有的状态派生出新的状态，并且自动追踪依赖关系，避免重复计算。计算属性使得代码更加直观简洁，尤其适用于在视图中计算和处理数据。 React 没有提供类似计算属性的功能，开发者需要在 JSX 中直接计算状态或者通过 Hooks 手动实现计算和依赖追踪，这往往增加了代码的复杂性。 4. 内置的指令和指令简化 Vue 提供了丰富的指令，例如 v-show, v-if, v-for, v-bind, v-on 等，使得常见的 DOM 操作和事件绑定变得简单明了。这些指令让开发者无需手动处理 DOM 或事件。 React 没有内置这些指令，开发者需要通过 JavaScript 或 JSX 语法来实现，逻辑上相对复杂。 5. 渐进式框架 Vue 是一个渐进式框架，提供了更灵活的集成方式。开发者可以将 Vue 作为一个库来为现有项目添加交互性，或者将其扩展为一个完整的前端框架，而不会像 React 一样要求从头到尾采用单一的方式。 React 主要作为视图层的库，不提供完整的框架式功能，开发者通常需要引入其他库（如 Redux, React Router）来构建复杂的应用。 6. Vue CLI 对于项目的支持 Vue CLI 提供了开箱即用的项目配置模板，能够快速生成 Vue 项目结构，自动支持 TypeScript、Babel、Linting 等配置。 React 虽然有 Create React App 作为项目初始化工具，但在某些特定项目需求下，Vue CLI 提供了更多的配置灵活性和插件支持。 7. 更好的组件通信（基于 props 和 emit 的模式） Vue 中，父子组件通信通过 props 和 emit 非常直观，遵循单向数据流。同时，Vue 3 提供了 provide/inject 机制，进一步简化了多层嵌套组件之间的通信。 React 主要通过 props 来实现父子组件通信，在更复杂的情况下，可能需要引入上下文 API 或其他状态管理工具。 8. 动画过渡支持 Vue 原生支持动画和过渡效果，通过 transition 和 transition-group 组件，开发者可以轻松为元素添加动画效果。 React 没有内置的动画功能，通常需要引入第三方库如 react-transition-group 或 framer-motion 来实现。 总结： Vue 在模板语法、双向绑定、计算属性、指令支持以及 CLI 工具等方面提供了更直观和简洁的解决方案，特别是在项目规模相对较小时，Vue 的学习曲线更平滑，开发体验更顺畅。而 React 的灵活性和生态系统广度适合构建更大型、复杂的应用，但需要更强的 JavaScript 基础。\n这并不是说 Vue 绝对优于 React，而是两者各有其适用场景，Vue 的方法和设计理念让它在某些开发场景中表现得更加简洁直观。\n18. vue 组件在什么时候会执行组件销毁？是当一个页面跳转到另一个页面时，之前的页面的组件都会被销毁吗？ 这是一个很好的问题，涉及到 Vue 组件的生命周期和路由管理。让我们详细探讨一下：\n组件销毁的时机 Vue 组件在以下情况下会被销毁：\na. 当组件被从 DOM 中移除时。 b. 当使用 v-if 指令且条件变为 false 时。 c. 当使用 v-for 指令且对应的数组项被移除时。 d. 当组件的父组件被销毁时。\n页面跳转时的组件销毁 关于页面跳转时组件是否被销毁，这取决于你的路由配置和应用结构：\na. 单页应用（SPA）中的普通路由切换：\n通常情况下，当从一个页面跳转到另一个页面时，前一个页面的组件会被销毁，新页面的组件会被创建。 这是因为在默认情况下，Vue Router 会在路由变化时卸载旧的组件，并挂载新的组件。 b. 使用 组件：\n如果你使用了 包裹路由组件，则组件在切换时不会被销毁，而是会被缓存。 这种情况下，组件会触发 deactivated 钩子而不是 destroyed 钩子，当再次进入时会触发 activated 钩子。 c. 嵌套路由：\n在嵌套路由的情况下，只有发生变化的部分会被销毁和重新创建，而共享的父级组件会保持不变。 d. 动态组件：\n使用 的动态组件，在切换时默认也会销毁旧组件并创建新组件，除非使用 。 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!-- App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 使用 keep-alive 的情况 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;keep-alive\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/keep-alive\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 验证组件销毁 你可以在组件中添加 destroyed 生命周期钩子来验证组件是否被销毁：\n1 2 3 4 5 export default { destroyed() { console.log(\u0026#39;Component destroyed\u0026#39;); } } 注意事项 组件销毁时，所有的事件监听器和子组件也会被销毁。 如果在组件中设置了定时器或添加了全局事件监听，应该在 beforeDestroy 或 destroyed 钩子中清理它们，以防止内存泄漏。 性能考虑 频繁地销毁和重建组件可能会影响性能。在某些情况下，使用 可以提高性能和用户体验。 但是过度使用 也可能导致内存占用增加，需要权衡。 Vue 3 的变化 在 Vue 3 中，生命周期钩子有些变化：\ndestroyed 改名为 unmounted beforeDestroy 改名为 beforeUnmount 总结： 在默认情况下，当在单页应用中从一个页面跳转到另一个页面时，前一个页面的组件通常会被销毁。但这个行为可以通过 、嵌套路由等方式来改变。了解组件的生命周期和销毁机制对于正确管理资源、优化性能和防止内存泄漏非常重要。\n","date":"2020-09-09T00:00:00Z","permalink":"https://trinyoung.github.io/interview/p/test-chinese3/","title":"vue 面试题汇总2"},{"content":"说一说网络的分层结构，各种协议分别位于哪一层？ 网络的分层结构通常指的是网络协议的分层模型，最常见的模型是 OSI（开放系统互联）模型 和 TCP/IP 模型。这两种模型都将网络通信过程分为多个层次，每一层都有特定的功能和协议。以下是这两种模型的简要介绍：\n1. OSI 模型 OSI 模型将网络通信分为七层，从上到下依次为：\n应用层（Application Layer）：\n负责用户与网络的交互，提供网络服务给应用程序。 协议示例：HTTP、FTP、SMTP、DNS。 表示层（Presentation Layer）：\n负责数据的格式化、加密和解密，确保数据能够被应用层理解。 处理数据的表示、编码和转换。 会话层（Session Layer）：\n负责建立、管理和终止会话，确保数据在会话中的顺序和完整性。 提供会话控制和同步。 传输层（Transport Layer）：\n负责数据的传输和完整性，提供端到端的通信。 协议示例：TCP、UDP。 网络层（Network Layer）：\n负责数据包的路由和转发，确定数据从源到目的地的路径。 协议示例：IP、ICMP。 数据链路层（Data Link Layer）：\n负责在物理网络上可靠地传输数据帧，处理物理地址和错误检测。 协议示例：Ethernet、PPP。 物理层（Physical Layer）：\n负责物理媒介的传输，定义电气信号、光信号和传输介质。 包括电缆、网卡、信号传输等。 2. TCP/IP 模型 TCP/IP 模型是互联网的基础，通常分为四层：\n应用层（Application Layer）：\n包含所有应用协议，负责用户与网络的交互。 协议示例：HTTP、FTP、SMTP。 传输层（Transport Layer）：\n负责数据的传输和完整性，提供端到端的通信。 协议示例：TCP、UDP。 网络层（Internet Layer）：\n负责数据包的路由和转发，确定数据从源到目的地的路径。 协议示例：IP、ICMP。 链路层（Link Layer）：\n负责在物理网络上可靠地传输数据帧，处理物理地址和错误检测。 包括 Ethernet、Wi-Fi 等。 3. 总结 分层结构的意义：网络的分层结构使得网络协议的设计和实现更加模块化，便于开发、维护和互操作性。每一层都可以独立发展，改变某一层的实现不会影响其他层。 功能分离：每一层都有特定的功能和协议，简化了网络通信的复杂性，使得网络系统更加灵活和可扩展。 get 请求和 post 请求的区别 GET 请求和 POST 请求是 HTTP 协议中最常用的两种请求方法，它们之间有几个关键的区别：\n1. 请求目的 GET 请求：\n用于从服务器获取数据。 请求的目的是获取资源，不会对服务器上的数据进行修改。 POST 请求：\n用于向服务器发送数据。 请求的目的是提交数据，通常用于创建或更新资源。 2. 数据传输方式 GET 请求：\n数据通过 URL 传递，通常附加在查询字符串中（例如：?key1=value1\u0026amp;key2=value2）。 URL 的长度有限制（通常为 2048 字符），因此不适合传输大量数据。 POST 请求：\n数据通过请求体（body）传递，不受 URL 长度限制。 可以传输大量数据，包括文件上传。 3. 安全性 GET 请求：\n数据在 URL 中可见，容易被缓存和记录，因此不适合传输敏感信息（如密码）。 GET 请求是幂等的，即多次请求相同的 URL 不会产生副作用。 POST 请求：\n数据在请求体中，不直接显示在 URL 中，相对更安全。 POST 请求不是幂等的，重复提交可能会导致数据重复或状态改变。 4. 缓存 GET 请求：\n可以被缓存，浏览器会缓存 GET 请求的响应，以提高性能。 POST 请求：\n通常不被缓存，浏览器不会缓存 POST 请求的响应。 5. 使用场景 GET 请求：\n用于获取数据，如获取网页、图片、API 数据等。 适合用于查询操作。 POST 请求：\n用于提交表单、上传文件、创建新资源等。 适合用于数据提交和修改操作。 总结 GET 请求：用于获取数据，通过 URL 传递参数，数据可见，适合查询操作。 POST 请求：用于提交数据，通过请求体传递参数，数据不直接可见，适合创建和更新操作。 选择使用 GET 还是 POST 请求取决于具体的应用场景和需求。\npost 请求和put/delete 请求的区别？ POST、PUT 和 DELETE 请求是 HTTP 协议中常用的请求方法，它们各自有不同的用途和语义。以下是它们之间的主要区别：\n1. 请求目的 POST 请求：\n用于向服务器提交数据，通常用于创建新资源。 请求的目的是将数据发送到服务器，服务器会处理这些数据并可能返回一个新的资源标识符。 PUT 请求：\n用于更新现有资源或创建新资源（如果资源不存在）。 请求的目的是将请求体中的数据替换服务器上指定资源的当前表示。 DELETE 请求：\n用于删除指定的资源。 请求的目的是从服务器上删除资源。 2. 数据传输方式 POST 请求：\n数据通过请求体（body）传递，通常用于提交表单数据或上传文件。 PUT 请求：\n数据也通过请求体传递，通常包含完整的资源表示，用于更新现有资源。 DELETE 请求：\n通常不需要请求体，删除操作通常只需要指定要删除的资源的 URL。 3. 幂等性 POST 请求：\n非幂等：多次发送相同的 POST 请求可能会导致创建多个资源。例如，提交相同的表单多次可能会创建多个相同的记录。 PUT 请求：\n幂等：多次发送相同的 PUT 请求会产生相同的结果。即使多次更新同一资源，最终的状态仍然是相同的。 DELETE 请求：\n幂等：多次发送相同的 DELETE 请求，第一次请求会删除资源，后续请求将不会有任何效果（因为资源已经被删除）。 4. 使用场景 POST 请求：\n用于创建新资源，如用户注册、提交表单等。 PUT 请求：\n用于更新现有资源，如更新用户信息、修改文章内容等。 DELETE 请求：\n用于删除资源，如删除用户、删除文章等。 5. 示例 POST 请求示例：\n1 2 3 4 5 6 7 POST /api/users Content-Type: application/json { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34; } PUT 请求示例：\n1 2 3 4 5 6 7 PUT /api/users/1 Content-Type: application/json { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john.doe@example.com\u0026#34; } DELETE 请求示例：\n1 DELETE /api/users/1 总结 POST 请求：用于创建新资源，非幂等。 PUT 请求：用于更新现有资源，幂等。 DELETE 请求：用于删除资源，幂等。 选择使用 POST、PUT 还是 DELETE 请求取决于具体的操作需求和资源管理策略。\n常见的http请求头和响应头有哪些？ HTTP 请求头和响应头是 HTTP 协议中用于传递信息的重要部分。以下是一些常见的请求头和响应头的分类及其说明。\n常见的 HTTP 请求头 Accept：指定客户端能够接收的内容类型。例如：\n1 Accept: application/json Content-Type：指示请求体中数据的类型，通常在 POST 和 PUT 请求中使用。例如：\n1 Content-Type: application/json Authorization：用于提供身份验证信息。例如：\n1 Authorization: Bearer \u0026lt;token\u0026gt; User-Agent：包含发起请求的客户端软件的信息。例如：\n1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Cookie：用于发送存储在客户端的 cookie 信息。例如：\n1 Cookie: sessionId=abc123 Host：指定请求的目标主机名和端口号。例如：\n1 Host: www.example.com Referer：指示请求的来源 URL。例如：\n1 Referer: https://www.example.com/page Accept-Encoding：指示客户端支持的内容编码方式，例如 gzip 或 deflate。例如：\n1 Accept-Encoding: gzip, deflate 常见的 HTTP 响应头 Content-Type：指示响应体中数据的类型。例如：\n1 Content-Type: application/json Content-Length：指示响应体的字节长度。例如：\n1 Content-Length: 348 Set-Cookie：用于在客户端设置 cookie。例如：\n1 Set-Cookie: sessionId=abc123; HttpOnly; Secure Cache-Control：指示缓存机制的指令。例如：\n1 Cache-Control: no-cache Expires：指示响应的过期时间。例如：\n1 Expires: Wed, 21 Oct 2021 07:28:00 GMT Location：用于重定向时指定新的 URL。例如：\n1 Location: https://www.example.com/new-page Server：指示响应的服务器软件信息。例如：\n1 Server: Apache/2.4.41 (Ubuntu) Access-Control-Allow-Origin：用于 CORS（跨源资源共享），指示允许哪些源访问资源。例如：\n1 Access-Control-Allow-Origin: * 总结 HTTP 请求头和响应头用于传递关于请求和响应的元数据。请求头包含客户端发送给服务器的信息，而响应头则包含服务器返回给客户端的信息。了解这些头部信息对于调试和优化 HTTP 请求和响应非常重要。\nhttp 响应返回304，代表什么含义，它使用的多好还是少好？ HTTP 响应状态码 304 表示 \u0026ldquo;Not Modified\u0026rdquo;（未修改）。它的含义和使用场景如下：\n1. 含义 304 Not Modified：当客户端向服务器发送请求时，通常会附带一个 If-Modified-Since 或 If-None-Match 头部，表示客户端希望获取自某个时间点以来是否有更新的资源。 如果服务器检查到请求的资源自上次请求以来没有被修改，它会返回 304 状态码，而不是返回完整的资源。这意味着客户端可以继续使用其缓存的版本，而不需要重新下载资源。 2. 使用场景 缓存优化：304 状态码主要用于优化缓存机制。通过减少不必要的数据传输，304 可以显著提高性能，尤其是在带宽有限或网络延迟较高的情况下。 减少服务器负担：当资源未修改时，服务器可以避免发送完整的响应体，从而减少服务器的负担和带宽消耗。 3. 使用的多好还是少好？ 使用得当：304 状态码的使用是非常有益的，尤其是在以下情况下：\n静态资源：对于静态资源（如图片、CSS、JavaScript 文件），使用 304 可以有效利用浏览器缓存，减少重复下载。 频繁访问的资源：对于频繁访问但不常变化的资源，304 可以显著提高用户体验和加载速度。 注意事项：\n缓存策略：为了有效使用 304 状态码，服务器需要正确配置缓存策略（如 Cache-Control 和 Expires 头部），以确保客户端能够正确判断资源是否已修改。 适用性：304 状态码适用于资源更新频率较低的场景。如果资源经常变化，使用 304 可能会导致客户端频繁请求服务器，反而增加负担。 弊端 频繁使用也会存在弊端 频繁使用 HTTP 304 状态码虽然在某些情况下可以优化性能和减少带宽消耗，但也可能带来一些弊端。以下是频繁使用 304 状态码可能导致的问题：\n1. 频繁的请求 增加请求数量：即使资源未修改，客户端仍然需要向服务器发送请求以检查资源的状态。这可能导致大量的请求，尤其是在高流量的应用中，增加了服务器的负担。 2. 服务器负担 处理请求的开销：每次请求都需要服务器进行处理，包括解析请求、检查条件（如 If-Modified-Since 或 If-None-Match），即使最终返回的是 304 状态码。这种处理开销在高并发情况下可能会显著增加服务器的负担。 3. 缓存失效 缓存策略复杂性：如果资源的更新频率较高，频繁使用 304 状态码可能导致客户端缓存失效，用户可能会看到过时的内容。为了确保用户获取最新内容，可能需要更频繁地更新缓存策略。 4. 用户体验 延迟：虽然 304 状态码不返回完整的资源，但客户端仍需等待服务器的响应。这可能导致用户在访问频繁更新的资源时体验到延迟，尤其是在网络条件不佳的情况下。 5. 适用性问题 不适合动态内容：对于动态内容或频繁变化的资源，使用 304 状态码可能并不合适。此时，直接返回最新的资源可能更有效。 6. 复杂的调试 调试困难：在调试过程中，频繁的 304 响应可能使得开发者难以确定资源的实际状态，增加了调试的复杂性。 7. 依赖于客户端的缓存 客户端缓存的可靠性：304 状态码依赖于客户端的缓存机制。如果客户端的缓存策略不当，可能导致用户获取到过时的资源。 总结 虽然 304 状态码在优化缓存和减少带宽消耗方面具有优势，但频繁使用也可能导致请求数量增加、服务器负担加重、用户体验下降等问题。因此，在使用 304 状态码时，开发者需要根据具体的应用场景和资源更新频率，合理配置缓存策略，以平衡性能和用户体验。\n4. 总结 HTTP 响应状态码 304 表示资源未修改，客户端可以使用缓存的版本。 304 的使用是有益的，特别是在优化缓存和减少带宽消耗方面。 适当配置缓存策略可以确保 304 状态码的有效性，从而提高性能和用户体验。 分别介绍一下什么是http1.0， 什么是http1.1，什么是http2.0甚至3.0的版本，它们之间的区别是什么？ 以下是对 HTTP/1.0、HTTP/1.1、HTTP/2.0 和 HTTP/3.0 的介绍，以及它们之间的主要区别。\n1. HTTP/1.0 定义：HTTP/1.0 是 HTTP 协议的第一个正式版本，于 1996 年发布。它定义了基本的请求和响应模型。 特点： 非持久连接：每个请求/响应对都需要建立一个新的 TCP 连接，完成后连接会关闭。 简单的请求和响应头：缺少一些重要的头部字段，功能较为有限。 缓存控制：主要依赖 Expires 头部进行缓存管理。 2. HTTP/1.1 定义：HTTP/1.1 是对 HTTP/1.0 的改进版本，于 1999 年发布。它引入了许多新特性和改进。 特点： 持久连接：默认使用持久连接，允许在同一连接上发送多个请求/响应，减少了连接建立的开销。 引入 Host 头部：允许在同一 IP 地址上托管多个域名。 更复杂的缓存控制：支持 Cache-Control 头部，提供更灵活的缓存策略。 分块传输编码：支持在不知道内容长度的情况下逐块发送响应。 更多的状态码：引入了更多的状态码，如 100（Continue）、206（Partial Content）等。 3. HTTP/2.0 定义：HTTP/2.0 于 2015 年发布，是对 HTTP/1.1 的重大改进，旨在提高性能和效率。 特点： 二进制协议：HTTP/2 使用二进制格式而非文本格式，减少了解析开销。 多路复用：允许在同一连接上并行发送多个请求和响应，解决了 HTTP/1.x 中的队头阻塞问题。 头部压缩：使用 HPACK 算法对头部进行压缩，减少了传输的数据量。 服务器推送：服务器可以主动向客户端推送资源，而无需客户端请求。 4. HTTP/3.0 定义：HTTP/3.0 是基于 QUIC 协议的 HTTP 版本，QUIC 是 Google 开发的传输层协议，旨在提高网络性能和安全性。 特点： 基于 UDP：与 HTTP/2 使用 TCP 不同，HTTP/3 使用 UDP，减少了连接建立和重传的延迟。 内置加密：QUIC 协议内置了加密功能，提供更好的安全性。 多路复用：同样支持多路复用，避免了队头阻塞问题。 连接迁移：支持在网络环境变化时保持连接（如从 Wi-Fi 切换到移动数据）。 5. 主要区别总结 特性 HTTP/1.0 HTTP/1.1 HTTP/2.0 HTTP/3.0 连接 非持久连接 持久连接 持久连接 基于 UDP 的连接 数据格式 文本 文本 二进制 二进制 多路复用 不支持 不支持 支持 支持 头部压缩 不支持 不支持 支持 支持 服务器推送 不支持 不支持 支持 支持 安全性 无内置加密 无内置加密 依赖于 TLS 内置加密 总结 HTTP/1.0 是最初的版本，功能简单，主要用于基本的请求和响应。 HTTP/1.1 引入了持久连接和更多的功能，成为广泛使用的版本。 HTTP/2.0 通过二进制协议和多路复用等特性显著提高了性能。 HTTP/3.0 基于 QUIC 协议，进一步减少延迟并增强安全性。 介绍一下什么是http3.0，它是如何保证数据的完整性和可靠性的？ HTTP/3.0 基于 QUIC 协议，而 QUIC 是一个基于 UDP 的传输层协议。尽管 UDP 本身不提供数据完整性和可靠性保障，QUIC 通过一系列机制来确保数据的完整性和可靠性。以下是 QUIC 如何实现这些目标的详细说明：\n1. 数据完整性 QUIC 使用 加密 和 消息认证码（MAC） 来确保数据的完整性：\n加密：QUIC 协议内置了加密功能，使用 TLS 1.3 进行加密。所有传输的数据都经过加密，确保数据在传输过程中不被篡改。 消息认证码（MAC）：QUIC 使用消息认证码来验证数据的完整性。每个数据包都包含一个 MAC，接收方可以使用这个 MAC 来验证数据是否在传输过程中被篡改。 2. 数据可靠性 QUIC 通过以下机制来确保数据的可靠性：\n重传机制：QUIC 实现了重传机制，确保丢失的数据包能够被重新发送。QUIC 会跟踪每个数据包的发送状态，并在检测到丢包时请求重传。 流控制：QUIC 使用流控制机制来管理数据流，确保发送方不会发送超过接收方处理能力的数据量。这有助于防止网络拥塞和数据丢失。 拥塞控制：QUIC 实现了拥塞控制算法，动态调整数据发送速率，以适应网络状况，减少丢包的可能性。 3. 连接迁移 QUIC 支持连接迁移，允许在网络条件变化时保持连接（例如，从 Wi-Fi 切换到移动数据）。这意味着即使在网络切换的情况下，QUIC 也能保持数据的完整性和可靠性。\n4. 多路复用 QUIC 支持多路复用，允许在同一连接上并行发送多个数据流。这减少了队头阻塞问题，并提高了数据传输的效率。\n5. 总结 数据完整性：QUIC 通过加密和消息认证码确保数据在传输过程中的完整性，防止数据被篡改。 数据可靠性：QUIC 实现了重传机制、流控制和拥塞控制，确保数据的可靠传输。 连接迁移和多路复用：QUIC 的设计使其能够在网络条件变化时保持连接，并有效利用带宽。 通过这些机制，QUIC 能够在基于 UDP 的传输中提供与 TCP 类似的可靠性和完整性保障，同时提高性能。\nhttp1.* 和 http2.0，http3.0 对于队头阻塞问题 HTTP/2 仍然存在一定程度的 队头阻塞（Head-of-Line Blocking） 问题，但和 HTTP/1.1 的队头阻塞相比，其表现形式和影响程度有所不同。\nHTTP/1.1 的队头阻塞问题 在 HTTP/1.1 中，队头阻塞指的是浏览器对同一个域名下的请求有并发连接数限制（通常是 6 个），当某个请求耗时较长或阻塞时，其他请求也会被阻挡，造成所有请求都需要等待。\nHTTP/2 的队头阻塞 HTTP/2 引入了多路复用（Multiplexing）机制，允许在一个 TCP 连接中并行传输多个请求和响应，解决了 HTTP/1.1 中的队头阻塞问题。然而，由于 HTTP/2 依赖于单个 TCP 连接，当这个 TCP 连接中的某个数据包丢失时，整个连接都会受到影响，导致所有请求都必须等待该数据包的重传。这种现象会导致 HTTP/2 的 TCP 层面仍然存在队头阻塞问题。\nHTTP/3 的改进 为了解决 HTTP/2 中的队头阻塞，HTTP/3 使用了基于 QUIC 协议 的传输方式。QUIC 是基于 UDP 的传输协议，支持独立的数据流传输，能够在丢包时仅影响丢失数据包所在的流，而不会阻塞其他流。这种机制彻底解决了 TCP 层面的队头阻塞问题。\n总结 HTTP/2 解决了 HTTP/1.1 的队头阻塞问题，但由于单个 TCP 连接的特性，在 TCP 层面仍可能发生队头阻塞。 HTTP/3 通过 QUIC 协议进一步解决了这一问题，实现了更高效的数据传输。 在 nginx 中，如何设置 http的版本？ 在 Nginx 中，可以通过配置文件中的 http 块来设置 HTTP 的版本。以下是如何设置 HTTP/1.1 和 HTTP/2 版本的方法：\n1. 配置 HTTP/1.1 HTTP/1.1 是默认的 HTTP 版本，所以一般情况下无需特别设置。\n配置示例：\n1 2 3 4 5 6 7 8 9 10 server { listen 80; server_name example.com; # 不需要额外配置，Nginx 会默认使用 HTTP/1.1 location / { root /usr/share/nginx/html; index index.html index.htm; } } 2. 配置 HTTP/2 如果想启用 HTTP/2，需要在 listen 指令中添加 http2 关键字，且 HTTP/2 需要使用 HTTPS（TLS/SSL）连接。\n配置示例：\n1 2 3 4 5 6 7 8 9 10 11 12 server { listen 443 ssl http2; # 开启 HTTP/2 server_name example.com; ssl_certificate /path/to/your/certificate.crt; ssl_certificate_key /path/to/your/private.key; location / { root /usr/share/nginx/html; index index.html index.htm; } } 注意事项： HTTP/2 仅在 HTTPS 下工作，所以需要配置 SSL 证书。 确保你的 Nginx 版本至少是 1.9.5 及以上，因为 HTTP/2 支持是从这个版本开始引入的。 完成以上配置后，重启 Nginx 使配置生效：\n1 sudo nginx -s reload 通过这种方式，你就可以在 Nginx 中设置 HTTP 版本了。\n如何在nginx中设置http3.0 要在 Nginx 中启用 HTTP/3.0，需要确保你的 Nginx 版本支持 HTTP/3，并且还要配置相关的 QUIC 协议。Nginx 支持 HTTP/3 的版本是从 Nginx 1.25.0 开始的（但需要注意，目前 HTTP/3 支持还在不断完善，建议使用较新的版本）。\n以下是配置 HTTP/3 的详细步骤：\n1. 安装支持 HTTP/3 的 Nginx 版本 确保你安装的 Nginx 版本支持 HTTP/3。你可以从官方源代码自行编译 Nginx，或者从第三方包管理工具中获取。\n2. 配置 Nginx 支持 HTTP/3 修改 Nginx 配置文件（通常在 /etc/nginx/nginx.conf 或 /etc/nginx/conf.d/ 目录下），按照以下步骤配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 server { listen 443 ssl http2; # 支持 HTTP/2 listen 443 ssl http2 reuseport; # 添加 reuseport，优化多核性能 listen 443 quic reuseport; # 启用 QUIC/HTTP3 ssl_certificate /path/to/your/certificate.crt; ssl_certificate_key /path/to/your/private.key; # 支持 TLS 1.3 ssl_protocols TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers off; # QUIC 需要配置的证书设置 ssl_certificate /path/to/your/cert.pem; ssl_certificate_key /path/to/your/privkey.pem; # HTTP/3 使用的 ALPN ssl_alpn \u0026#34;h3\u0026#34; \u0026#34;http/1.1\u0026#34;; # 指定 QUIC 的设置 http3_max_concurrent_streams 128; quic_idle_timeout 3m; quic_ack_delay_exponent 3; quic_initial_window_size 65536; add_header Alt-Svc \u0026#39;h3-23=\u0026#34;:443\u0026#34;\u0026#39;; # 指定支持 HTTP/3 add_header QUIC-Status $quic; location / { root /usr/share/nginx/html; index index.html index.htm; } } 3. 启用 QUIC 和 HTTP/3 确保开启了 QUIC 和 HTTP/3 的支持。配置中 listen 443 quic reuseport; 是关键。 4. 防火墙设置 确保防火墙允许 UDP 443 端口，因为 QUIC 使用的是 UDP 协议，而不是传统的 TCP。\n5. 检查 Nginx 配置和重启 确保配置没有语法错误：\n1 sudo nginx -t 然后重启 Nginx：\n1 sudo systemctl restart nginx 注意事项 浏览器支持：目前最新版本的 Chrome、Firefox、Edge 等浏览器支持 HTTP/3。 服务器支持：确认服务器支持 QUIC 及 HTTP/3，并确保系统环境、库等都符合要求。 说一下tcp的三次握手过程？ TCP（传输控制协议）使用三次握手（Three-Way Handshake）过程来建立可靠的连接。这个过程确保了客户端和服务器之间的连接是可靠的，并且双方都准备好进行数据传输。以下是三次握手的详细步骤：\n1. 第一次握手（SYN） 客户端发送 SYN：客户端向服务器发送一个 SYN（同步序列编号）包，表示请求建立连接。这个包中包含客户端的初始序列号（ISN）。\n1 客户端 → 服务器: SYN, seq = x 2. 第二次握手（SYN-ACK） 服务器响应 SYN-ACK：服务器收到客户端的 SYN 包后，确认请求并发送一个 SYN-ACK（同步-确认）包作为响应。这个包中包含服务器的初始序列号（ISN）和对客户端 SYN 的确认号（即客户端的序列号 + 1）。\n1 服务器 → 客户端: SYN-ACK, seq = y, ack = x + 1 3. 第三次握手（ACK） 客户端发送 ACK：客户端收到服务器的 SYN-ACK 包后，发送一个 ACK（确认）包，确认收到服务器的 SYN-ACK。这个包中包含对服务器 SYN 的确认号（即服务器的序列号 + 1）。\n1 客户端 → 服务器: ACK, seq = x + 1, ack = y + 1 4. 连接建立 在完成这三次握手后，客户端和服务器之间的连接建立成功，双方可以开始数据传输。 总结 三次握手的目的： 确保双方都准备好进行通信。 确保双方的初始序列号（ISN）已被确认。 提供可靠的连接建立机制，确保数据传输的可靠性。 通过三次握手，TCP 协议能够建立一个可靠的连接，确保数据的完整性和顺序性。\n说一下TCP断开连接的4次挥手 TCP 断开连接的过程称为四次挥手（Four-Way Handshake），用于安全地关闭一个 TCP 连接。这个过程确保双方都能正常地结束连接，避免数据丢失。以下是四次挥手的详细步骤：\n1. 第一次挥手（FIN） 主动关闭方发送 FIN：主动关闭连接的一方（通常是客户端）发送一个 FIN（结束）包，表示它已经完成数据的发送，并希望关闭连接。\n1 客户端 → 服务器: FIN, seq = x 2. 第二次挥手（ACK） 被动关闭方响应 ACK：服务器收到 FIN 包后，发送一个 ACK（确认）包，确认收到客户端的 FIN。此时，服务器仍然可以继续发送数据。\n1 服务器 → 客户端: ACK, seq = y, ack = x + 1 3. 第三次挥手（FIN） 被动关闭方发送 FIN：当服务器完成数据发送后，它也会发送一个 FIN 包，表示它也希望关闭连接。\n1 服务器 → 客户端: FIN, seq = z 4. 第四次挥手（ACK） 主动关闭方响应 ACK：客户端收到服务器的 FIN 包后，发送一个 ACK 包，确认收到服务器的 FIN。此时，连接正式关闭。\n1 客户端 → 服务器: ACK, seq = x + 1, ack = z + 1 5. 连接关闭 在完成这四次挥手后，TCP 连接被安全地关闭，双方都可以释放相关的资源。 总结 四次挥手的目的： 确保双方都能正常地结束连接。 确保所有未发送的数据都能被正确传输。 避免数据丢失，确保连接的可靠关闭。 通过四次挥手，TCP 协议能够安全地断开连接，确保数据的完整性和可靠性。\nGET 请求为什么要限制url的长度？ GET 请求限制 URL 长度的原因主要包括以下几点：\n1. 浏览器和服务器的限制 浏览器限制：不同的浏览器对 URL 的最大长度有不同的限制。虽然大多数现代浏览器支持较长的 URL，但仍然存在一个上限（通常在 2000 到 8000 字符之间）。超出这个限制可能导致请求失败。\n服务器限制：服务器软件（如 Apache、Nginx 等）也可能对 URL 长度设置限制。如果请求的 URL 超过服务器的最大长度限制，服务器可能会拒绝处理该请求。\n2. HTTP 协议规范 HTTP 规范：HTTP 协议并没有明确规定 URL 的最大长度，但为了确保兼容性和可移植性，许多实现都遵循了某些约定。过长的 URL 可能会导致解析和处理上的问题。 3. 性能考虑 性能影响：较长的 URL 会增加网络传输的负担，尤其是在需要频繁发送请求的情况下。较长的 URL 可能会导致更高的延迟和更低的性能。 4. 安全性 安全风险：过长的 URL 可能会引发安全问题，例如 URL 注入攻击。限制 URL 长度可以减少潜在的攻击面。 5. 适用场景 GET 请求的设计：GET 请求通常用于获取资源，参数应尽量简洁。对于复杂的查询或大量数据，推荐使用 POST 请求，因为 POST 请求的数据是通过请求体发送的，没有长度限制。 总结 GET 请求限制 URL 的长度主要是为了兼容性、性能、安全性和协议规范的考虑。对于需要传递大量数据或复杂参数的情况，使用 POST 请求更为合适。\n请说出对http协议中，keep-alive 对理解？ 在 HTTP 协议中，Keep-Alive 是一种机制，用于在同一 TCP 连接上保持多个请求和响应的持续连接。它允许客户端和服务器在完成一个请求后，不立即关闭连接，而是保持连接的打开状态，以便后续的请求可以复用该连接。这种机制可以显著提高性能和效率，减少延迟和资源消耗。\n1. 工作原理 持久连接：在 HTTP/1.1 中，持久连接是默认启用的，客户端和服务器可以在同一连接上发送多个请求和响应。通过在请求和响应头中使用 Connection: keep-alive，可以明确表示希望保持连接。\n连接保持时间：服务器可以设置一个超时时间（如 Keep-Alive: timeout=5），在此时间内，如果没有新的请求到达，服务器将关闭连接。\n2. 优势 减少延迟：通过复用连接，避免了每次请求都需要重新建立 TCP 连接的开销，从而减少了延迟。\n降低资源消耗：减少了连接的建立和关闭次数，降低了服务器和客户端的资源消耗。\n提高吞吐量：在同一连接上发送多个请求可以提高数据传输的效率，尤其是在高延迟的网络环境中。\n3. 使用场景 静态资源请求：在请求静态资源（如图片、CSS、JavaScript 文件）时，使用 Keep-Alive 可以显著提高加载速度。\n频繁请求的应用：在需要频繁进行请求的应用（如 AJAX 请求）中，使用持久连接可以提高性能。\n4. 注意事项 连接管理：虽然 Keep-Alive 可以提高性能，但过多的持久连接可能会导致服务器资源的浪费。因此，服务器通常会设置最大连接数和超时时间，以合理管理连接。\nHTTP/2 的优势：在 HTTP/2 中，持久连接的概念被进一步增强，支持多路复用，允许在同一连接上并行发送多个请求和响应，进一步提高了性能。\n总结 Keep-Alive 是 HTTP 协议中的一种机制，允许在同一 TCP 连接上保持多个请求和响应的持续连接。它通过减少连接建立和关闭的开销，提高了性能和效率，适用于需要频繁请求的场景。\n与缓存相关的头部信息有哪些？ 在 HTTP 中，与缓存相关的头部信息主要包括以下几种：\n1. 请求头 Cache-Control：\n用于指定请求和响应的缓存指令。可以控制缓存的行为，如 no-cache、no-store、max-age 等。 示例： 1 2 Cache-Control: no-cache Cache-Control: max-age=3600 If-Modified-Since：\n用于向服务器询问自指定时间以来资源是否已被修改。如果资源未修改，服务器可以返回 304 Not Modified。 示例： 1 If-Modified-Since: Wed, 21 Oct 2021 07:28:00 GMT If-None-Match：\n用于向服务器询问资源的 ETag（实体标签）。如果 ETag 匹配，服务器可以返回 304 Not Modified。 示例： 1 If-None-Match: \u0026#34;etag_value\u0026#34; 2. 响应头 Cache-Control：\n同样用于响应中，指定缓存的指令。 示例： 1 Cache-Control: public, max-age=86400 Expires：\n指定响应的过期时间。过期后，缓存的内容被视为过时。 示例： 1 Expires: Wed, 21 Oct 2021 07:28:00 GMT Last-Modified：\n指示资源的最后修改时间。客户端可以使用此信息与 If-Modified-Since 一起进行条件请求。 示例： 1 Last-Modified: Wed, 21 Oct 2021 07:28:00 GMT ETag：\n提供资源的实体标签，用于标识特定版本的资源。客户端可以使用此信息与 If-None-Match 一起进行条件请求。 示例： 1 ETag: \u0026#34;etag_value\u0026#34; Pragma：\n用于向旧版 HTTP/1.0 客户端指示缓存控制。通常用于 no-cache。 示例： 1 Pragma: no-cache 总结 这些缓存相关的头部信息在 HTTP 中用于控制和管理缓存的行为，帮助提高性能和减少不必要的数据传输。合理使用这些头部可以有效地优化网络请求和响应的效率。\nTLS/SSL 的工作原理 TLS/SSL全称安全传输层协议（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。\nTLS/SSL的功能实现主要依赖三类基本算法：散列函数hash、对称加密、非对称加密。这三类算法的作用如下：\n基于散列函数验证信息的完整性 对称加密算法采用协商的秘钥对数据加密 非对称加密实现身份认证和秘钥协商 （1）散列函数hash 常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。\n特点：在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。 （2）对称加密 对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。\n常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。\n特点：对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。 （3）非对称加密 非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。\n常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。\n特点：非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。\n综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。\nCA 证书是什么，详解一下它的工作流程？ 什么是中间人攻击 中间人攻击（Man-in-the-Middle Attack，MITM）是一种网络攻击方式，攻击者在通信双方之间秘密地拦截和篡改信息。攻击者可以伪装成通信的任一方，从而获取敏感信息（如用户名、密码、信用卡信息等）或操控通信内容。中间人攻击通常发生在不安全的网络环境中，例如公共 Wi-Fi。\n中间人攻击的工作原理 拦截通信：攻击者通过各种手段（如 ARP 欺骗、DNS 欺骗等）拦截客户端与服务器之间的通信。 伪装身份：攻击者伪装成客户端或服务器，向另一方发送请求或响应。 篡改数据：攻击者可以修改传输的数据，甚至注入恶意代码。 获取敏感信息：攻击者可以记录通信内容，获取敏感信息。 应对中间人攻击的办法 使用 HTTPS：\n确保网站使用 HTTPS 协议，利用 TLS/SSL 加密通信，防止数据在传输过程中被窃取或篡改。 验证证书：\n客户端在建立连接时应验证服务器的数字证书，确保其由受信任的 CA 签发，并检查证书的有效性和完整性。 使用 VPN：\n在公共 Wi-Fi 网络中使用虚拟专用网络（VPN），加密所有网络流量，增加数据传输的安全性。 避免公共 Wi-Fi：\n尽量避免在公共 Wi-Fi 网络中进行敏感操作，如在线银行、购物等。如果必须使用，确保使用 VPN。 启用双因素认证：\n使用双因素认证（2FA）增加额外的安全层，即使攻击者获取了密码，也无法轻易访问账户。 保持软件更新：\n定期更新操作系统、浏览器和应用程序，以修补已知的安全漏洞，降低被攻击的风险。 使用强密码：\n使用复杂且唯一的密码，避免使用容易猜测的密码，定期更换密码。 监测异常活动：\n监控账户和网络活动，及时发现异常行为，采取相应措施。 总结 中间人攻击是一种严重的网络安全威胁，通过拦截和篡改通信内容，攻击者可以获取敏感信息或操控数据。通过使用 HTTPS、验证证书、使用 VPN、避免公共 Wi-Fi、启用双因素认证等措施，可以有效降低中间人攻击的风险，保护用户的敏感信息和数据安全。\n什么是xss 攻击？ XSS（跨站脚本攻击）通常利用用户输入的内容（如评论、留言等）来注入恶意脚本。以下是一些 XSS 攻击的示例，特别是针对评论输入的恶意脚本，以及它们如何在服务器中执行。\n示例 1：存储型 XSS 假设一个网站允许用户在评论区发布评论，但没有对输入进行适当的过滤和编码。攻击者可以提交以下恶意评论：\n1 \u0026lt;script\u0026gt;alert(\u0026#39;XSS Attack!\u0026#39;);\u0026lt;/script\u0026gt; 如何执行： 用户提交评论：攻击者在评论区输入上述代码并提交。 服务器存储：服务器将该评论存储在数据库中，未进行任何过滤。 其他用户访问：当其他用户访问该评论时，网页会从数据库中读取评论并直接插入到 HTML 中。 脚本执行：浏览器解析 HTML 时，执行了 \u0026lt;script\u0026gt; 标签中的 JavaScript 代码，导致弹出警告框。 示例 2：反射型 XSS 攻击者可以构造一个恶意链接，利用 URL 参数注入脚本。例如：\n1 http://example.com/comment?text=\u0026lt;script\u0026gt;alert(\u0026#39;Reflected XSS!\u0026#39;);\u0026lt;/script\u0026gt; 如何执行： 用户点击链接：用户点击攻击者发送的链接。 服务器处理请求：服务器接收到请求，提取 text 参数并将其直接插入到响应的 HTML 中。 脚本执行：浏览器解析响应时，执行了 \u0026lt;script\u0026gt; 标签中的 JavaScript 代码，导致弹出警告框。 示例 3：DOM 型 XSS 假设网页使用 JavaScript 从 URL 中提取参数并直接插入到 DOM 中：\n1 2 const userComment = new URLSearchParams(window.location.search).get(\u0026#39;comment\u0026#39;); document.getElementById(\u0026#39;comments\u0026#39;).innerHTML += userComment; 如果用户访问以下链接：\n1 http://example.com/?comment=\u0026lt;script\u0026gt;alert(\u0026#39;DOM XSS!\u0026#39;);\u0026lt;/script\u0026gt; 如何执行： 用户访问链接：用户访问包含恶意参数的链接。 JavaScript 执行：JavaScript 代码从 URL 中提取 comment 参数并将其插入到页面中。 脚本执行：浏览器执行了插入的脚本，导致弹出警告框。 总结 在这些示例中，恶意脚本在服务器中被存储或反射为普通文本，但由于缺乏适当的输入验证和输出编码，当这些文本被插入到 HTML 中时，浏览器将其视为可执行的代码，从而导致 XSS 攻击的发生。为了防止 XSS 攻击，开发者应始终对用户输入进行严格的验证和过滤，并在输出时进行适当的编码。\n如何防范xss 攻击 你提到的对 innerHTML 的使用确实是防止 XSS 攻击的重要方面。以下是一些具体的防御措施，可以帮助开发者有效防止 XSS 攻击：\n1. 避免使用 innerHTML 尽量避免使用 innerHTML 来插入用户输入的内容。可以使用 textContent 或 innerText 来安全地插入文本，这样可以防止浏览器将输入内容解析为 HTML。\n1 2 3 // 安全的插入方式 const userComment = urlParams.get(\u0026#39;comment\u0026#39;); document.getElementById(\u0026#39;userComment\u0026#39;).textContent = userComment; // 使用 textContent 2. 输入验证和过滤 对用户输入进行严格的验证，确保只接受预期的格式。例如，对于评论内容，可以限制字符类型、长度等。 3. 输出编码 在将用户输入输出到 HTML 中时，进行适当的编码。可以使用库（如 DOMPurify）来清理和编码用户输入，确保不执行任何恶意脚本。\n1 2 3 // 使用 DOMPurify 进行清理 const cleanComment = DOMPurify.sanitize(userComment); document.getElementById(\u0026#39;userComment\u0026#39;).innerHTML = cleanComment; 4. 使用安全的 HTTP 头 设置 Content-Security-Policy（CSP）头，限制可执行的脚本来源。CSP 可以帮助防止 XSS 攻击，因为它限制了哪些资源可以被加载和执行。\n1 Content-Security-Policy: default-src \u0026#39;self\u0026#39;; script-src \u0026#39;self\u0026#39;; 5. 避免直接插入用户输入 尽量避免直接将用户输入插入到 DOM 中。使用安全的 API 处理用户输入，例如使用 createElement 和 appendChild 方法。\n1 2 3 const commentElement = document.createElement(\u0026#39;span\u0026#39;); commentElement.textContent = userComment; // 使用 textContent document.getElementById(\u0026#39;comments\u0026#39;).appendChild(commentElement); 6. 定期安全审计 定期对应用程序进行安全审计和渗透测试，及时发现和修复 XSS 漏洞。 7. 使用框架的安全特性 如果使用现代前端框架（如 React、Vue、Angular），它们通常会自动处理 XSS 问题，确保用户输入被安全地处理。尽量利用这些框架的安全特性。 敏感信息的保护 对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。\n总结 防止 XSS 攻击需要综合考虑多个方面，特别是在处理用户输入时要格外小心。通过避免使用 innerHTML、进行输入验证和输出编码、使用安全的 HTTP 头等措施，可以有效降低 XSS 攻击的风险，保护用户的安全。\n什么是CSRF 攻击？ CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。\nCSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。 （2）攻击类型 常见的 CSRF 攻击有三种：\nGET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。 POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。 链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。 如何防范？ 进行同源检测，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）\n使用 CSRF Token 进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。\n对 Cookie 进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。\n在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。\n网络劫持有几种，如何防范？ ⽹络劫持分为两种: （1）DNS劫持: (输⼊京东被强制跳转到淘宝这就属于dns劫持)\nDNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器 302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容 （2）HTTP劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告) DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。\n浏览器中有哪些进程？ 在现代浏览器中，通常会使用多进程架构来提高性能、安全性和稳定性。以下是浏览器中常见的进程类型：\n1. 浏览器主进程（Browser Process） 功能：负责管理整个浏览器的用户界面、标签页、地址栏、书签、历史记录等。它还负责与操作系统进行交互，处理用户输入和事件。 特点：通常只有一个主进程，负责协调其他进程的工作。 2. 渲染进程（Renderer Process） 功能：负责渲染网页内容，包括 HTML、CSS 和 JavaScript 的解析和执行。每个标签页通常会有一个独立的渲染进程。 特点：渲染进程与主进程相互独立，崩溃一个渲染进程不会影响其他标签页的运行。 3. GPU 进程（GPU Process） 功能：负责处理图形渲染任务，如 CSS 动画、WebGL 渲染等。将图形处理任务分配给 GPU 进程可以提高性能和效率。 特点：通常只有一个 GPU 进程，负责多个渲染进程的图形处理。 4. 网络进程（Network Process） 功能：负责处理网络请求和响应，包括 HTTP 请求、WebSocket 连接等。它还负责管理缓存和代理设置。 特点：在某些浏览器中，网络处理可能与渲染进程合并，但在多进程架构中，通常会有独立的网络进程。 5. 插件进程（Plugin Process） 功能：负责运行浏览器插件（如 Flash、Java 等）。由于插件可能会影响浏览器的稳定性和安全性，通常会将其放在独立的进程中。 特点：每个插件可能会有自己的进程，确保插件崩溃不会影响主浏览器。 6. 服务工作线程（Service Worker） 功能：在后台运行，处理网络请求、缓存和推送通知等。服务工作线程可以在浏览器关闭时继续运行，提供离线支持。 特点：每个服务工作线程是独立的，能够与多个页面进行通信。 7. Web Worker 功能：用于在后台线程中执行 JavaScript 代码，避免阻塞主线程。适用于处理计算密集型任务。 特点：Web Worker 运行在独立的线程中，不能直接访问 DOM。 总结 现代浏览器采用多进程架构，通过将不同的功能模块分配到独立的进程中，提高了性能、安全性和稳定性。主要的进程包括浏览器主进程、渲染进程、GPU 进程、网络进程、插件进程、服务工作线程和 Web Worker。这样的设计使得浏览器能够更好地处理复杂的网页和用户交互。\n进程之间的通信方式有哪些？ 说一下浏览器的缓存 浏览器缓存的全过程：\n浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用； 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期； 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求； 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200； 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200； 什么是浏览器的强缓存什么是协商缓存？两者的区别是什么? 浏览器缓存的全过程：\n浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用； 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期； 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求； 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200； 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200； 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\n强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。\n（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。 （2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，\nCache-Control可设置的字段：\npublic：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制； private：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存； no-cache：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源； no-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源； max-age=：设置缓存的最大有效期，单位为秒； s-maxage=：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头； max-stale[=]：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。 一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。\nno-cache和no-store很容易混淆：\nno-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存； no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。 （2）协商缓存 如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。 上面已经说到了，命中协商缓存的条件有两个：\nmax-age=xxx 过期了 值为no-store 使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。\n协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。 （1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。 （2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。\n当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。\n总结： 强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。\n点击刷新或者按F5，按Ctrl+F5（强制刷新）、地址栏回车有什么区别？ 点击刷新、按 F5 和 Ctrl+F5 的区别在于它们对浏览器缓存的处理方式不同：\n点击刷新按钮 / F5：\n操作：浏览器会先检查本地缓存，看是否有该页面的资源，如果有则使用缓存。 协商缓存：会向服务器发出请求，验证缓存的有效性。如果资源未改变，服务器会返回 304 Not Modified，浏览器会使用缓存的资源。如果资源已改变，服务器会返回最新的资源。 适用场景：适合在页面内容不经常改变的情况下使用，减少不必要的网络请求。 Ctrl + F5（强制刷新）：\n操作：忽略本地缓存，直接从服务器重新下载所有资源。无论缓存是否有效，都会请求服务器获取最新资源。 适用场景：用于希望获取页面最新内容或怀疑缓存内容已过期但没有自动更新时使用。会占用更多带宽和加载时间，但保证内容是最新的。 地址栏回车：\n操作：和点击刷新 / F5 类似，也会检查缓存并进行请求验证。一般不会强制刷新缓存。 总结：\n点击刷新 / F5 和 地址栏回车：会使用缓存，只有在必要时才请求服务器。 Ctrl + F5：跳过缓存，强制请求服务器获取最新资源。 这些不同操作在开发和调试过程中非常有用，因为它们提供了灵活的缓存控制方式，确保页面资源的最新性或快速加载。\n浏览器的渲染原理 浏览器的渲染的流程 浏览器的渲染流程主要包括以下几个步骤：\n解析 HTML：\n浏览器会解析 HTML 文档，生成 DOM（Document Object Model）树。这是一个将 HTML 文档组织成树形结构的过程，所有的 HTML 元素都会转换为 DOM 树中的节点。 解析 CSS：\n与 HTML 并行，浏览器会解析 CSS 样式表，生成 CSSOM（CSS Object Model）树。CSSOM 是将所有 CSS 样式解析成树形结构的对象模型。 构建 Render Tree（渲染树）：\n将 DOM 树与 CSSOM 树结合，生成渲染树（Render Tree）。渲染树包含了每个需要显示的节点以及它们的样式信息，不包括 display: none 的元素，也不包括非可见节点。 布局（Layout）：\n有了渲染树后，浏览器会计算每个节点的大小和位置，确定元素在页面上的确切位置。这一过程称为“布局”或“回流（Reflow）”。 绘制（Painting）：\n布局完成后，浏览器会根据渲染树对每个节点进行绘制，将其内容显示在屏幕上。这包括将文本、颜色、图像、边框等渲染出来。 合成与显示（Compositing）：\n浏览器将页面划分为多个图层，进行合成，然后将这些图层渲染到屏幕上。不同图层可以独立绘制和合成，以减少重绘和重排的成本，提升性能。 总结： 浏览器的渲染流程大致可以概括为：解析 HTML -\u0026gt; 解析 CSS -\u0026gt; 构建 Render Tree -\u0026gt; 布局 -\u0026gt; 绘制 -\u0026gt; 合成与显示。这些步骤紧密相连，确保了页面的内容能高效地在屏幕上呈现。\n理解这个流程有助于优化网页的性能，例如，减少 DOM 操作、合并 CSS 文件、避免频繁触发回流和重绘，都可以提升页面的渲染效率。\n","date":"2020-09-09T00:00:00Z","permalink":"https://trinyoung.github.io/interview/p/http-browser/","title":"网络协议和浏览器基础知识"}]